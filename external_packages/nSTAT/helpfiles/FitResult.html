
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>FitResult</title><meta name="generator" content="MATLAB 7.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2011-02-09"><meta name="DC.source" content="FitResult.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><pre class="codeinput"><span class="keyword">classdef</span> FitResult &lt; handle
    <span class="comment">% FITRESULT</span>
    <span class="comment">% stores results of a fit using the Analysis object</span>
    <span class="comment">% The results are for a single neuron over a range of configurations</span>
    <span class="comment">% &lt;a href="matlab:web('FitResultExamples.html', '-helpbrowser')"&gt;FitResult Examples&lt;/a&gt;</span>
    <span class="comment">% see also &lt;a href="matlab:help('Analysis')"&gt;Analysis&lt;/a&gt;</span>
    <span class="comment">% Reference page in Help browser</span>
    <span class="comment">% &lt;a href="matlab:doc('FitResult')"&gt;doc FitResult&lt;/a&gt;</span>
    <span class="keyword">properties</span>
       numResults   <span class="comment">%Number of results in this FitResult object</span>
       lambda       <span class="comment">%Lambda signal</span>
       numCoeffs    <span class="comment">%Number of coefficients for each fitResult</span>
       fitType      <span class="comment">%Poisson or Binomial</span>

       b            <span class="comment">%coefficients for each fit</span>
       dev          <span class="comment">%deviance for each fit</span>
       AIC          <span class="comment">%Akaike's Information Criterion for each fit</span>
       BIC          <span class="comment">%Baysian Information Criterion for each fit</span>
       stats        <span class="comment">%Relevant statistics for each fit</span>
       configs      <span class="comment">% the config collection for the different fits</span>
       configNames  <span class="comment">% names of the the differen fits</span>
       neuronNumber <span class="comment">% the number of the neuron the data comes from</span>
       neuralSpikeTrain <span class="comment">% the spike data</span>
       covLabels
       uniqueCovLabels
       indicesToUniqueLabels
       numHist        <span class="comment">% Number of history terms (used for indexing into the regression coefficients) for each fit</span>
       histObjects    <span class="comment">% History object for self firing</span>
       ensHistObjects <span class="comment">% History object to be applied to the neuron's neigbors to compute ensemble effect</span>
       flatMask
       Z    <span class="comment">% Rescaled spike times from the Time-Rescaling theorem, exponential rate 1</span>
       U    <span class="comment">% Transformed z's -&gt; uniform in [0,1]</span>
       X    <span class="comment">% Transformed u's -&gt; gaussian in [-inf, inf]</span>
       Residual <span class="comment">%fit residual</span>
<span class="comment">%        xAxis</span>
<span class="comment">%        KSSorted</span>
<span class="comment">%        ks_stat</span>
       invGausStats
       KSStats  <span class="comment">%Kolmogorov Smirnov Statistics</span>
       plotParams
       XvalData <span class="comment">% cell array of raw data used for validation</span>
       XvalTime <span class="comment">% cell array of time vectors for each element of XvalData</span>
       validation <span class="comment">% a FitResult object with the validation data</span>
       minTime  <span class="comment">% The minTime from the spikeTrain (not necessarily the analysis)</span>
       maxTime  <span class="comment">% The maxTime for the spikeTrain (not necessarily the analysis)</span>
    <span class="keyword">end</span>
    <span class="keyword">properties</span> (Constant,Hidden)
        colors={<span class="string">'b'</span>,<span class="string">'g'</span>,<span class="string">'r'</span>,<span class="string">'c'</span>,<span class="string">'m'</span>,<span class="string">'y'</span>,<span class="string">'k'</span>};
    <span class="keyword">end</span>


    <span class="keyword">methods</span>

        <span class="keyword">function</span> fitObj=FitResult(spikeObj,covLabels,numHist,histObjects,ensHistObj,lambda,b, dev, stats,AIC,BIC,configColl,XvalData,XvalTime,distribution)
            <span class="comment">% fitObj=FitResult(spikeObj,covLabels,numHist,histObjects,ensHistObj,lambda,b, dev, stats,AIC,BIC,configColl,XvalData,XvalTime)</span>
            <span class="comment">% Stores the results of multiple regressions for a single  neuron into a accessible structure.</span>
            <span class="comment">%</span>
            <span class="comment">% spikeObj: The spike train for the neuron whose results are</span>
            <span class="comment">%           being stored.</span>
            <span class="comment">% covLabels: A 2-d cell array, the jth row has all the labels for the covariates used in the jth fit</span>
            <span class="comment">% numHist: The number of history terms in each of the N fits.</span>
            <span class="comment">% histObjects: The History object for each of the N fits</span>
            <span class="comment">% ensHistObj: The History object for used to compute the ensemble history effect.</span>
            <span class="comment">% lambda: The conditional intensity function evaluated usin the</span>
            <span class="comment">% data. Each dimension of lambda corresponds to the a different</span>
            <span class="comment">%       GLM Fit.</span>
            <span class="comment">% b: N-component cell array containing the GLM regression</span>
            <span class="comment">%    coefficient of each of the fits. The jth component has all</span>
            <span class="comment">%    the regression coefficients for the jth trial.</span>
            <span class="comment">% dev: vector of Deviances for each the GLM fits.</span>
            <span class="comment">% stats: Cell array of the stats parameters for each GLM fit;</span>
            <span class="comment">% AIC: vector of Akaike's information criteria for each the GLM fits.</span>
            <span class="comment">% BIC: vector of Bayes Information criteria for each the GLM fits.</span>
            <span class="comment">% configColl: configCollection object used to generate this</span>
            <span class="comment">%             results</span>
            <span class="comment">% XvalData: Data to be used for validation.</span>
            <span class="comment">% XvalTime: Time vector for the data.</span>

            <span class="keyword">if</span>(nargin&lt; 14)
                XvalTime =[];
            <span class="keyword">end</span>
            <span class="keyword">if</span>(nargin&lt;13)
                XvalData =[];
            <span class="keyword">end</span>

            <span class="keyword">if</span>(isnumeric(spikeObj.name))
                nNumber =spikeObj.name;
            <span class="keyword">else</span>
                nNumber = str2double(spikeObj.name(~isletter(spikeObj.name)));
            <span class="keyword">end</span>
            fitObj.neuronNumber = nNumber; <span class="comment">%str2num(spikeObj.name);</span>
            fitObj.neuralSpikeTrain = spikeObj;
            fitObj.minTime = spikeObj.minTime;
            fitObj.maxTime = spikeObj.maxTime;
            fitObj.numResults = 0;
            fitObj.configs = configColl;
            fitObj.configNames = configColl.getConfigNames;
            fitObj.covLabels=covLabels;
            fitObj.uniqueCovLabels= getUniqueLabels(covLabels);

            fitObj.mapCovLabelsToUniqueLabels;
            fitObj.numHist=numHist;
            fitObj.histObjects = histObjects;
            fitObj.ensHistObjects = ensHistObj;
            fitObj.addParamsToFit(fitObj.neuronNumber,lambda,b, dev, stats,AIC,BIC,configColl);
            fitObj.Z        =[]; <span class="comment">%rescaled spikes times - exponentially dist.</span>
            fitObj.U        =[]; <span class="comment">%rescaled spike times - uniformly dist.</span>
            fitObj.X        =[]; <span class="comment">%rescaled spike times - gaussian dist.</span>
            fitObj.Residual =[]; <span class="comment">%fit residual for PP</span>
            fitObj.KSStats.xAxis    =[];
            fitObj.KSStats.KSSorted =[];
            fitObj.KSStats.ks_stat  =[];
            fitObj.invGausStats.rhoSig=[];
            fitObj.invGausStats.confBoundSig=[];
            fitObj.plotParams = [];
            fitObj.XvalData = XvalData;
            fitObj.XvalTime = XvalTime;

            fitObj.fitType = distribution;

        <span class="keyword">end</span>
        <span class="keyword">function</span> mFitRes = mergeResults(fitObj,newFitObj)
            <span class="keyword">if</span>(isa(newFitObj,<span class="string">'FitResult'</span>))
                <span class="keyword">if</span>(fitObj.neuronNumber ==newFitObj.neuronNumber)
                    spikeObj = fitObj.neuralSpikeTrain;
                    covLabels = fitObj.covLabels(1:fitObj.numResults);
                    covLabels((fitObj.numResults+1):(fitObj.numResults+newFitObj.numResults)) = newFitObj.covLabels(1:newFitObj.numResults);
                    numHist = fitObj.numHist(1:fitObj.numResults);
                    numHist((fitObj.numResults+1):(fitObj.numResults+newFitObj.numResults)) = newFitObj.numHist(1:newFitObj.numResults);
                    histObjects=fitObj.histObjects(1:fitObj.numResults);
                    histObjects((fitObj.numResults+1):(fitObj.numResults+newFitObj.numResults)) = newFitObj.histObjects(1:newFitObj.numResults);
                    ensHistObjects=fitObj.ensHistObjects(1:fitObj.numResults);
                    ensHistObjects((fitObj.numResults+1):(fitObj.numResults+newFitObj.numResults)) = newFitObj.ensHistObjects(1:newFitObj.numResults);
                    b=fitObj.b(1:fitObj.numResults);
                    b((fitObj.numResults+1):(fitObj.numResults+newFitObj.numResults)) = newFitObj.b(1:newFitObj.numResults);
                    dev = [fitObj.dev newFitObj.dev];
                    AIC = [fitObj.AIC newFitObj.AIC];
                    BIC = [fitObj.BIC newFitObj.BIC];
                    stats=fitObj.stats(1:fitObj.numResults);
                    stats((fitObj.numResults+1):(fitObj.numResults+newFitObj.numResults)) = newFitObj.stats(1:newFitObj.numResults);
                    lambda = fitObj.lambda.merge(newFitObj.lambda);

                    <span class="keyword">for</span> i=1:fitObj.numResults
                        config{i}=fitObj.configs.getConfig(i);
                    <span class="keyword">end</span>
                    offset=fitObj.numResults;
                    <span class="keyword">for</span> i=1:newFitObj.numResults
                        config{i+offset}=newFitObj.configs.getConfig(i);
                    <span class="keyword">end</span>
                    configColl= ConfigColl(config);

                    XvalData = [fitObj.XvalData newFitObj.XvalData];
                    XvalTime = [fitObj.XvalTime newFitObj.XvalTime];
                    distribution=fitObj.fitType(1:fitObj.numResults);
                    distribution((fitObj.numResults+1):(fitObj.numResults+newFitObj.numResults)) = newFitObj.fitType(1:newFitObj.numResults);
                    Z=[fitObj.Z newFitObj.Z];
                    U=[fitObj.U newFitObj.U];
                    [X,rhoSig,confBoundSig] = Analysis.computeInvGausTrans(Z);

                    M=fitObj.Residual.merge(newFitObj.Residual);
                    xAxis    = [fitObj.KSStats.xAxis newFitObj.KSStats.xAxis];
                    KSSorted = [fitObj.KSStats.KSSorted newFitObj.KSStats.KSSorted];
                    ks_stat  = [fitObj.KSStats.ks_stat newFitObj.KSStats.ks_stat];
                    mFitRes=FitResult(spikeObj,covLabels,numHist,histObjects,ensHistObjects,lambda,b, dev, stats,AIC,BIC,configColl,XvalData,XvalTime,distribution);
                    mFitRes.setKSStats(Z,U, xAxis, KSSorted, ks_stat);
                    mFitRes.setInvGausStats(X,rhoSig,confBoundSig);
                    mFitRes.setFitResidual(M);


                <span class="keyword">elseif</span>(isa(newFitObj,<span class="string">'cell'</span>))
                    <span class="keyword">if</span>(isa(newFitObj{1},<span class="string">'FitResult'</span>))
                        <span class="keyword">for</span> i=1:length(newFitObj)
                            <span class="keyword">if</span>(i==1)
                                mFitRes = fitObj.mergeResults(newFitObj{i});
                            <span class="keyword">else</span>
                                mFitRes = mFitRes.mergeResults(newFitObj{i});
                            <span class="keyword">end</span>
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>

        <span class="keyword">end</span>
        <span class="keyword">function</span> addParamsToFit(fitObj,neuronNum,lambda,b, dev, stats,AIC,BIC,configColl)
            <span class="comment">% addParamsToFit(fitObj,neuronNum,lambda,b, dev, stats,AIC,BIC,configColl)</span>
            <span class="comment">% Add the specified parameters to the current FitResult object</span>
            <span class="comment">% only if the neuronNum matches the neuronNum of this object</span>
            <span class="keyword">if</span>(fitObj.neuronNumber==neuronNum)
              <span class="keyword">if</span>(isa(lambda,<span class="string">'cell'</span>))
                  newLambda=lambda{1};
                  <span class="keyword">for</span> i=2:length(lambda)
                      newLambda = newLambda.merge(lambda{i});
                  <span class="keyword">end</span>
              <span class="keyword">elseif</span>(isa(lambda,<span class="string">'Covariate'</span>)||isa(lambda,<span class="string">'SignalObj'</span>))
                  newLambda = lambda;
              <span class="keyword">end</span>

              numNewResults = newLambda.dimension;<span class="comment">%number of new elements</span>
              <span class="keyword">if</span>(nargin&lt;8)
                  configColl = cell(1,numNewResults);
              <span class="keyword">end</span>

              <span class="keyword">if</span>(numNewResults==1)
                      fitObj.b{fitObj.numResults+1}    = b{1};
                      fitObj.dev(fitObj.numResults+1)  = dev;
                      fitObj.stats{fitObj.numResults+1}= stats{1};
                      <span class="keyword">if</span>(nargin&lt;7)
                          fitObj.AIC(fitObj.numResults+1)  = 2*length(b)+dev;
                          fitObj.BIC(fitObj.numResults+1)  = length(b)*log(length(newLambda.time))+dev;
                      <span class="keyword">else</span>
                          fitObj.AIC(fitObj.numResults+1)  = AIC;
                          fitObj.BIC(fitObj.numResults+1)  = BIC;
                      <span class="keyword">end</span>

                      fitObj.numCoeffs(fitObj.numResults+1) = length(b);
              <span class="keyword">else</span>
                  <span class="keyword">for</span> i=1:numNewResults
                      fitObj.b{fitObj.numResults+i}    = b{i};
                      fitObj.dev(fitObj.numResults+i)  = dev(i);
                      fitObj.stats{fitObj.numResults+i}= stats{i};
                      <span class="keyword">if</span>(nargin&lt;7)
                          fitObj.AIC(fitObj.numResults+i)  = 2*length(b{i})+dev(i);
                          fitObj.BIC(fitObj.numResults+i)  = length(b{i})*log(length(newLambda.time))+dev(i);
                      <span class="keyword">else</span>
                          fitObj.AIC(fitObj.numResults+i)  = AIC(i);
                          fitObj.BIC(fitObj.numResults+i)  = BIC(i);
                      <span class="keyword">end</span>
                      fitObj.numCoeffs(fitObj.numResults+i) = length(b{i});
                  <span class="keyword">end</span>
              <span class="keyword">end</span>
              <span class="keyword">if</span>(fitObj.numResults ==0)
                  fitObj.lambda = newLambda;
              <span class="keyword">else</span>
                fitObj.lambda = fitObj.lambda.merge(newLambda); <span class="comment">%new lambda</span>
              <span class="keyword">end</span>

              fitObj.numResults = fitObj.numResults+numNewResults;
              dataLabels = cell(1,fitObj.numResults);
              <span class="keyword">for</span> i=1:fitObj.numResults
                 dataLabels{i} = strcat(<span class="string">'\lambda_'</span>,num2str(i));
              <span class="keyword">end</span>
              fitObj.lambda.setDataLabels(dataLabels);

              fitObj.configs.addConfig(configColl);
              fitObj.configNames = fitObj.configs.getConfigNames;
          <span class="keyword">else</span>
              error(<span class="string">'Neuron number does not match'</span>);
          <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">function</span> lambda = computeValLambda(fitObj)
            <span class="comment">% lambda = computeValLambda(fitObj)</span>
            <span class="comment">% Returns a Covariate object lambda. This is the Conditional</span>
            <span class="comment">% intensity function evaluated using the validation data</span>
            lambdaData = zeros(length(fitObj.XvalTime{1}),fitObj.numResults);
            <span class="keyword">for</span> i=1:fitObj.numResults
                lambdaData(:,i) = fitObj.evalLambda(i,fitObj.XvalData{i});
            <span class="keyword">end</span>
            lambda=Covariate(fitObj.XvalTime{1},lambdaData,<span class="keyword">...</span>
                  <span class="string">'\Lambda(t)'</span>,fitObj.lambda.xlabelval,<span class="keyword">...</span>
                  fitObj.lambda.xunits,<span class="string">'Hz'</span>,fitObj.lambda.dataLabels);
        <span class="keyword">end</span>

        <span class="keyword">function</span> mapCovLabelsToUniqueLabels(fitObj)
            flatMask = zeros(length(fitObj.uniqueCovLabels),length(fitObj.covLabels));
            <span class="keyword">for</span> j=1:length(fitObj.covLabels)
                currLabels = fitObj.covLabels{j};
                index=zeros(1,length(currLabels));
                <span class="keyword">for</span> i=1:length(currLabels)
                    index(i)=strmatch(currLabels{i}, fitObj.uniqueCovLabels, <span class="string">'exact'</span>);
                <span class="keyword">end</span>

                fitObj.indicesToUniqueLabels{j} = index;
                flatMask(index,j) = 1;
            <span class="keyword">end</span>
            fitObj.flatMask = flatMask;
        <span class="keyword">end</span>
        <span class="keyword">function</span> p=getPlotParams(fitObj)
            <span class="comment">% p=getPlotParams(fitObj)</span>
            <span class="keyword">if</span>(isempty(fitObj.plotParams))
                fitObj.computePlotParams;
            <span class="keyword">end</span>
                p=fitObj.plotParams;
        <span class="keyword">end</span>
        <span class="keyword">function</span> plotValidation(fitObj)
            <span class="comment">% plotValidation(fitObj)</span>
            <span class="comment">% calls plotResults on the validation FitResult object if</span>
            <span class="comment">% validation data is present. Note that the GLM coefficients</span>
            <span class="comment">% are not recomputed and therefore the same as those obtained</span>
            <span class="comment">% from the training data.</span>
            <span class="keyword">if</span>(~isempty(fitObj.validation))
                fitObj.validation.plotResults;
            <span class="keyword">else</span>
                display(<span class="string">'Validation Data not available to plot'</span>);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">function</span> answer = isValDataPresent(fitObj)
            <span class="comment">% answer = isValDataPresent(fitObj)</span>
            <span class="comment">% returns 1 if validation data is present. This method is used</span>
            <span class="comment">% to determine if validation data is available to compute the</span>
            <span class="comment">% validation results.</span>
            answer = 0;
            <span class="keyword">if</span>(~isempty(fitObj.XvalTime) &amp;&amp; ~isempty(fitObj.XvalData))
                <span class="keyword">for</span> i=1:length(fitObj.XvalTime)
                    currTime = fitObj.XvalTime{i};
                    <span class="keyword">if</span>(~isempty(currTime))
                        <span class="keyword">if</span>(currTime(end)-currTime(1)&gt;0)
                            answer =1;
                            <span class="keyword">break</span>;
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>

            <span class="keyword">end</span>

        <span class="keyword">end</span>
        <span class="keyword">function</span> lambdaData = evalLambda(fitObj,lambdaIndex,newData)
            <span class="comment">% lambdaData = evalLambda(fitObj,lambdaIndex,newData)</span>
            <span class="comment">% lambdaIndex: the index of the corresponding lambda to be</span>
            <span class="comment">%              evaluated with the new data.</span>
            <span class="comment">% newData:     matrix of covariates in same order as fits without</span>
            <span class="comment">%              constant term in first column</span>
<span class="comment">%             if(isa(newData,'double'))</span>
<span class="comment">%                 [~,columns] = size(newData);</span>
<span class="comment">%                 tempData = cell(1,columns);</span>
<span class="comment">%                 for i=1:columns</span>
<span class="comment">%                    tempData{i} = newData(:,i);</span>
<span class="comment">%                 end</span>
<span class="comment">%                 newData = tempData;</span>
<span class="comment">%             end</span>

            <span class="keyword">if</span>(lambdaIndex&gt;0 &amp;&amp; lambdaIndex &lt;= fitObj.numResults)
                b=fitObj.b{lambdaIndex}; <span class="comment">%coefficient matrix</span>
                <span class="keyword">if</span>(isempty(newData))
                    [rows,~] = size(newData);
                    baseline=ones(rows,1);
                    lambdaData =  exp(b(1)*baseline);
                <span class="keyword">else</span>
                    <span class="keyword">if</span>(isa(newData,<span class="string">'double'</span>)) <span class="comment">%matrix, 1 column per coefficient</span>
                        baseline=ones(length(newData),1);
                        [~,columns] = size(newData);

                        <span class="keyword">if</span>(length(b)&gt;=1)
                            lambdaData = exp(newData*b(1:end));
                            <span class="keyword">if</span>(strcmp(fitObj.fitType{lambdaIndex},<span class="string">'poisson'</span>))
<span class="comment">%                                 lambdaData = exp(newData*b(1:end));</span>
<span class="comment">%                                 lambdaData = exp(b(1) + newData*b(2:end));</span>
                            <span class="keyword">else</span>
<span class="comment">%                                 lambdaData = exp(b(1) + newData*b(2:end));</span>
                                lambdaData = lambdaData./(1+lambdaData);
                            <span class="keyword">end</span>
<span class="comment">%                         else</span>
<span class="comment">%                             if(strcmp(fitObj.fitType{lambdaIndex},'poisson'))</span>
<span class="comment">%                                 lambdaData = exp(b(1)*baseline);</span>
<span class="comment">%</span>
<span class="comment">%                             else</span>
<span class="comment">%                                 lambdaData = exp(b(1)*baseline);</span>
<span class="comment">%                                 lambdaData = lambdaData./(1+lambdaData);</span>
<span class="comment">%                             end</span>
                        <span class="keyword">end</span>
                        lambdaData = lambdaData*fitObj.neuralSpikeTrain.sampleRate;
                    <span class="keyword">elseif</span>(isa(newData,<span class="string">'cell'</span>)) <span class="comment">% a cell array, each element is matrix of values for each coeff</span>
<span class="comment">%                         baseline=ones(size(newData{1})); %design matrix</span>
                            runSum=0;
                        <span class="keyword">for</span> i=1:(length(newData)) <span class="comment">%-fitObj.numHist(lambdaIndex))</span>
<span class="comment">%                             if(i==1)</span>
<span class="comment">%                                 runSum = b(1)*baseline;</span>
<span class="comment">%                             else</span>
                                runSum = runSum+b(i)*newData{i-1};
<span class="comment">%                             end</span>
                        <span class="keyword">end</span>
                        <span class="keyword">if</span>(strcmp(fitObj.fitType{lambdaIndex},<span class="string">'poisson'</span>))
                            lambdaData = exp(runSum);
                            lambdaData = lambdaData*fitObj.neuralSpikeTrain.sampleRate;
                        <span class="keyword">else</span>
                            lambdaData = exp(runSum);
                            lambdaData = lambdaData./(1+lambdaData);
                            lambdaData = lambdaData*fitObj.neuralSpikeTrain.sampleRate;
                        <span class="keyword">end</span>
                    <span class="keyword">else</span>
                        error(<span class="string">'New data must be cell or a matrix'</span>);
                    <span class="keyword">end</span>

                <span class="keyword">end</span>
            <span class="keyword">else</span>
                error(<span class="string">'Index into fit params is incorrect'</span>);
            <span class="keyword">end</span>

        <span class="keyword">end</span>
<span class="comment">%         function handle = plotHist(fitObj,fitNum)</span>
<span class="comment">%            % handle = plotHist(fitObj,fitNum)</span>
<span class="comment">%            % plots the history terms used in this FitResult object</span>
<span class="comment">%            % if fitNum is not specified then fitNum=1:numResults</span>
<span class="comment">%            if(nargin&lt;2 || isempty(fitNum))</span>
<span class="comment">%                fitNum = 1:fitObj.numResults;</span>
<span class="comment">%            end</span>
<span class="comment">%</span>
<span class="comment">%            for j=fitNum</span>
<span class="comment">%                if(j&gt;0 &amp;&amp; j &lt;= fitObj.numResults)</span>
<span class="comment">%                     b=fitObj.b{j}; %coefficient matrix</span>
<span class="comment">%                     startHistIndex = length(b)-fitObj.numHist(j)+1;</span>
<span class="comment">%                     if(startHistIndex&lt;length(b))</span>
<span class="comment">%                         bHist = b(startHistIndex:end);</span>
<span class="comment">%                         if(~isempty(fitObj.histObjects{j}))</span>
<span class="comment">%                             windowTimes = fitObj.histObjects{j}.windowTimes;</span>
<span class="comment">%                             t=linspace(windowTimes(1),windowTimes(end),100)';</span>
<span class="comment">%                             histEffect = zeros(length(t),1);</span>
<span class="comment">%                             for i=1:length(windowTimes)-1</span>
<span class="comment">%                                 index = and(t&gt;=windowTimes(i),t&lt;=windowTimes(i+1));</span>
<span class="comment">%                                 histEffect(index)=exp(-bHist(i))-1; %To offset zero coeffs</span>
<span class="comment">%                             end</span>
<span class="comment">%                         end</span>
<span class="comment">%                     else</span>
<span class="comment">%                         t=[0; 0.00001];</span>
<span class="comment">%                         histEffect =[0;0];</span>
<span class="comment">%                     end</span>
<span class="comment">%                     if(j==fitNum(1))</span>
<span class="comment">%                         hSig = SignalObj(t,histEffect,'History','time','s','',fitObj.lambda.dataLabels{j});</span>
<span class="comment">%                     else</span>
<span class="comment">%                         hSig = hSig.merge(SignalObj(t,histEffect,'History Effect','time','s','',fitObj.lambda.dataLabels{j}));</span>
<span class="comment">%                     end</span>
<span class="comment">%                end</span>
<span class="comment">%            end</span>
<span class="comment">%            N=floor(length(hSig.time)./70); B=ones(1,N)/N; A=1;</span>
<span class="comment">%            handle=hSig.filtfilt(B,A).plot;</span>
<span class="comment">%         end</span>
        <span class="keyword">function</span> computePlotParams(fitObj,fitNum)
             <span class="keyword">if</span>(nargin&lt;2)
               fitNum = 1:fitObj.numResults;
             <span class="keyword">end</span>
           index=find(sum(fitObj.flatMask,2)&gt;0);<span class="comment">%1:length(fitObj.flatMask(:,1));</span>
           <span class="comment">%Only use the labels that appear in at least one fit</span>
           <span class="comment">%Otherwise that parameter was not present for any of the</span>
           <span class="comment">%regressions and just takes up plot real-estate</span>

           sigIndex=zeros(length(index),length(fitNum));
           bAct = nan(length(index),length(fitNum));
           seAct= nan(length(index),length(fitNum));

           <span class="keyword">for</span> i=fitNum
               <span class="comment">%this indexing is to avoid extremely large se's from</span>
               <span class="comment">%affecting plots</span>
               criteria = find(fitObj.stats{i}.se'&lt;100);
               <span class="comment">%indicesForFit = find(fitObj.flatMask(index,i)==1);</span>
               indicesForFit = fitObj.indicesToUniqueLabels{i};
               bVals = fitObj.b{i}(criteria);
               bAct(indicesForFit(criteria),i) = bVals; <span class="comment">%sorted according to uniqueLabels</span>
               seVals = fitObj.stats{i}.se(criteria)';
               seAct(indicesForFit(criteria),i)= seVals; <span class="comment">%sorted according to uniqueLabels;</span>
               temp = sign([bAct(:,i)-seAct(:,i) bAct(:,i)+seAct(:,i)]);
               productOfSigns = temp(:,1).*temp(:,2); <span class="comment">%should be positive</span>
               sIndex=and(productOfSigns&gt;0,seAct(:,i)~=0);
               sigIndex(:,i)=sIndex;
           <span class="keyword">end</span>
           fitObj.plotParams.bAct = bAct;
           fitObj.plotParams.seAct= seAct;
           fitObj.plotParams.sigIndex = sigIndex;
           fitObj.plotParams.xLabels  = cell(length(index),1);
           fitObj.plotParams.xLabels = fitObj.uniqueCovLabels;

<span class="comment">%            for i=1:(length(index))</span>
<span class="comment">%                if(i==1)</span>
<span class="comment">%                    fitObj.plotParams.xLabels{i} = 'baseline';</span>
<span class="comment">%                    %text(i, 0,'baseline','interpreter','latex');</span>
<span class="comment">%                else</span>
<span class="comment">%                    fitObj.plotParams.xLabels{i} = fitObj.covLabels{index(i)-1};</span>
<span class="comment">%                    %text(i, 0,fitObj.covLabels{index(i)-1},'interpreter','latex');</span>
<span class="comment">%                end</span>
<span class="comment">%            end</span>
           tempVal =sum(fitObj.flatMask,2);
           fitObj.plotParams.numResultsCoeffPresent =tempVal(index);
        <span class="keyword">end</span>
        <span class="keyword">function</span> h=plotCoeffs(fitObj,handle,fitNum,plotProps,plotSignificance)
           <span class="comment">% h=plotCoeffs(fitObj,handle,fitNum,plotProps,plotSignificance)</span>
           <span class="comment">% plots the GLM coefficients for each fit along with the</span>
           <span class="comment">% confidence intervals.</span>
           <span class="comment">% fitNum: number of the fit to plot. If not specified, all are</span>
           <span class="comment">%         plotted.</span>
           <span class="comment">% plotProps: properties to use for the making the plot</span>
           <span class="comment">% plotSignificance: If 1 then an asterix (*) is place above</span>
           <span class="comment">%                   parameters that are statistically different</span>
           <span class="comment">%                   from zero with alpha=5%.</span>

           <span class="keyword">if</span>(nargin&lt;5)
               plotSignificance = 1;
           <span class="keyword">end</span>

           <span class="keyword">if</span>(nargin&lt;4 || isempty(plotProps))
               plotProps = [];
           <span class="keyword">end</span>

           <span class="keyword">if</span>(nargin&lt;3 || isempty(fitNum))
               fitNum = 1:fitObj.numResults;
           <span class="keyword">end</span>

           <span class="keyword">if</span>(nargin&lt;2 || isempty(handle))
               handle=gca;
           <span class="keyword">end</span>

           <span class="keyword">if</span>(isempty(fitObj.plotParams))
               fitObj.computePlotParams(fitNum);
           <span class="keyword">end</span>

           bAct = fitObj.getPlotParams.bAct;
           seAct= fitObj.getPlotParams.seAct;
           sigIndex=fitObj.getPlotParams.sigIndex;

           <span class="keyword">if</span>(~isempty(plotProps))
               <span class="keyword">for</span> i=1:length(fitNum)
                    h=errorbar(handle,1:length(index),bAct,seAct,plotProps{i}); hold <span class="string">on</span>;
               <span class="keyword">end</span>
           <span class="keyword">else</span>
               Xaxis=repmat(1:length(bAct(:,1)),[length(bAct(1,:)) 1]);
               h=errorbar(handle,Xaxis',bAct,seAct,<span class="string">'.'</span>);<span class="comment">%strcat('.',FitResult.colors{mod(i-1,length(FitResult.colors))+1}));</span>
           <span class="keyword">end</span>

            hold <span class="string">on</span>;


            <span class="keyword">if</span>(plotSignificance==1)
               v=axis;
               vdiff = .8*v(4);

               <span class="keyword">for</span> i=fitNum
                  plot(handle,find(sigIndex(:,i)==1),vdiff*ones(length(find(sigIndex(:,i)==1)),1)-i*.1,strcat(<span class="string">'.'</span>,FitResult.colors{mod(i-1,length(FitResult.colors))+1})); hold <span class="string">on</span>;
               <span class="keyword">end</span>
            <span class="keyword">end</span>
           ylabel(<span class="string">'Fit Coefficients'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>);
           xtickLabels = fitObj.getPlotParams.xLabels;
           xticks = 1:(length(xtickLabels));

           set(handle,<span class="string">'xtick'</span>,xticks,<span class="string">'xtickLabel'</span>,xtickLabels,<span class="string">'FontSize'</span>,6);
           <span class="keyword">if</span>(max(fitObj.numCoeffs)&gt;1)
            xticklabel_rotate([],90,[],<span class="string">'Fontsize'</span>,6);
           <span class="keyword">end</span>
<span class="comment">%            hT=rotateticklabel(gca,-90);</span>
           legend(handle,fitObj.lambda.dataLabels,<span class="string">'Location'</span>,<span class="string">'Best'</span>);
           <span class="comment">%axis tight;</span>

        <span class="keyword">end</span>
        <span class="keyword">function</span> plotResults(fitObj)
            <span class="comment">% plotResults(fitObj)</span>
            <span class="comment">% Generates KS plot, auto-correlation function of the inverse</span>
            <span class="comment">% gaussian transformed rescaled ISIs, the sequential</span>
            <span class="comment">% correlation coefficient between neigboring pairs of the</span>
            <span class="comment">% rescaled ISIs (zj vs. zj-1), the GLM regression coefficients,</span>
            <span class="comment">% and the Point Process Residual.</span>
                scrsz = get(0,<span class="string">'ScreenSize'</span>);
                figure(<span class="string">'Position'</span>,[scrsz(3)*.1 scrsz(4)*.1 scrsz(3)*.8 scrsz(4)*.8]);

                subplot(2,4,[1 2]); fitObj.KSPlot; <span class="comment">%make the plot</span>
                text(.45, .95,strcat(<span class="string">'Neuron:'</span>,num2str(fitObj.neuronNumber)));
                subplot(2,4,3); fitObj.plotInvGausTrans;
                subplot(2,4,4); fitObj.plotSeqCorr;
                subplot(2,4,[7 8]); fitObj.plotResidual;
                subplot(2,4,[5 6]); fitObj.plotCoeffs;
        <span class="keyword">end</span>
        <span class="keyword">function</span> handle = KSPlot(fitObj)
            <span class="comment">% handle = KSPlot(fitObj)</span>
            <span class="comment">% computes the K-S plot for each of the the candidate rate</span>
            <span class="comment">% functions in this FitResult object. These candidate rate</span>
            <span class="comment">% functions are numbered according to the order in which they</span>
            <span class="comment">% were added to the FitResult.</span>
            h=gcf;
            <span class="comment">%h=[];</span>
            figure(h);
        <span class="comment">%     size(xAxis)</span>
        <span class="comment">%     size(KSSorted)</span>
            N = length(fitObj.KSStats.KSSorted);
            xaxis = fitObj.KSStats.xAxis(:,1);
            handle=plot(fitObj.KSStats.xAxis,fitObj.KSStats.KSSorted, xaxis,xaxis, <span class="string">'k-.'</span>,xaxis, xaxis+1.36/sqrt(N), <span class="string">'r'</span>, xaxis,xaxis-1.36/sqrt(N), <span class="string">'r'</span> );

            <span class="comment">%set(gca,'xtick',[],'ytick',[],'ztick', [])</span>
            axis( [0 1 0 1] );
            dataLabels = cell(1,fitObj.lambda.dimension);
            <span class="keyword">for</span> i=1:fitObj.lambda.dimension
                dataLabels{i} = fitObj.lambda.dataLabels{i};
            <span class="keyword">end</span>
            legend(dataLabels,<span class="string">'Location'</span>,<span class="string">'Best'</span>);
            xlabel(<span class="string">'Uniform CDF'</span>);
            ylabel(<span class="string">'Empirical CDF of Rescaled ISIs'</span>);
            title(<span class="string">'KS Plot with 95% Confidence Intervals'</span>);


        <span class="keyword">end</span>

        <span class="keyword">function</span> structure = toStructure(fitObj)
            <span class="comment">%</span>
            fnames = fieldnames(fitObj);

            <span class="keyword">for</span> i=1:length(fnames)

                currObj = fitObj.(fnames{i});
                <span class="keyword">if</span>(strcmp(fnames{i},<span class="string">'histObjects'</span>)||strcmp(fnames{i},<span class="string">'ensHistObjects'</span>))
                    <span class="keyword">for</span> j=1:fitObj.numResults
                        tempObj = fitObj.(fnames{i}){j};
                        <span class="keyword">if</span>(~isempty(tempObj))
                            structure.(fnames{i}){j} = tempObj.toStructure;
                        <span class="keyword">else</span>
                            structure.(fnames{i}){j} = tempObj;
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">elseif</span>(strcmp(fnames{i},<span class="string">'invGausStats'</span>))
                    tempNames = fieldnames(fitObj.(fnames{i}));
                    <span class="keyword">for</span> j=1:length(tempNames)
                       tempObj = currObj.(tempNames{j});
                       <span class="keyword">if</span>(~isempty(tempObj))
                        structure.(fnames{i}).(tempNames{j})=  tempObj.dataToStructure;
                       <span class="keyword">else</span>
                         structure.(fnames{i}).(tempNames{j})=  tempObj;
                       <span class="keyword">end</span>

                    <span class="keyword">end</span>

                <span class="keyword">else</span>

                    <span class="keyword">if</span>(isa(currObj,<span class="string">'double'</span>)||isa(currObj,<span class="string">'cell'</span>))
                        structure.(fnames{i}) = currObj;
                    <span class="keyword">elseif</span>(isa(currObj,<span class="string">'Covariate'</span>) ||isa(currObj,<span class="string">'ConfigColl'</span>)||isa(currObj,<span class="string">'nspikeTrain'</span>))
                        structure.(fnames{i}) = currObj.toStructure;
                    <span class="keyword">elseif</span>(isa(currObj,<span class="string">'SignalObj'</span>))
                        structure.(fnames{i})  = currObj.dataToStructure;
                    <span class="keyword">elseif</span>(isa(currObj,<span class="string">'struct'</span>))
                        structure.(fnames{i}) = currObj;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>

        <span class="keyword">end</span>


        <span class="keyword">function</span> handle = plotSeqCorr(fitObj)
            <span class="comment">% handle = plotSeqCorr(fitObj)</span>
            <span class="comment">% plot zj+1 against zj</span>

            <span class="comment">%colors = {'.b','.g','.r','.c','.m','.y','.k'};</span>
            rho=zeros(1,fitObj.numResults);
            pval=zeros(1,fitObj.numResults);
            dataLabels = fitObj.lambda.dataLabels;
            <span class="keyword">for</span> i=1:fitObj.numResults
               handle = plot(fitObj.Z(1:end-1,i),fitObj.Z(2:end,i),strcat(<span class="string">'.'</span>,Analysis.colors{mod(i-1,length(Analysis.colors))+1})); hold <span class="string">on</span>;
               [rhoTemp,p]= corrcoef(fitObj.Z(1:end-1,i),fitObj.Z(2:end,i));<span class="comment">%handle=scatterhist(fitResults.Z(1:end-1,i),fitResults.Z(2:end,i))</span>

               [~,columns]=size(rhoTemp);
                <span class="keyword">if</span>(columns&gt;1)
                    rho(i) = rhoTemp(1,2);
                    pval(i)= p(1,2);
                <span class="keyword">else</span>
                    rho(i) = rhoTemp;
                    pval(i)= p;
                <span class="keyword">end</span>
               dataLabels{i} = strcat(dataLabels{i},<span class="string">', \rho='</span>,num2str(rho(i),<span class="string">'%0.2g'</span>),<span class="string">' (p='</span>,num2str(pval(i),<span class="string">'%0.2g'</span>),<span class="string">')'</span>);
                <span class="comment">%get(h,'AlphaData');</span>
                <span class="comment">%set(h,'FaceAlpha',0.2,'EdgeAlpha',0.8,'EdgeColor',color{i});</span>
            <span class="keyword">end</span>


            legend(dataLabels,<span class="string">'Location'</span>,<span class="string">'Best'</span>);
            ylabel(<span class="string">'z_{j+1}'</span>); xlabel(<span class="string">'z_j'</span>);
            axis <span class="string">tight</span>;
        <span class="keyword">end</span>
        <span class="keyword">function</span> handle = plotInvGausTrans(fitObj)
            <span class="comment">%[rows,colm] = size(fitObj.X);</span>
            <span class="comment">%index=find(fitObj.invGausStats.lags==1);</span>
            <span class="comment">%lags=fitObj.invGausStats.lags;</span>
            rhoSig=fitObj.invGausStats.rhoSig;
            n=length(fitObj.X);
            confBoundSig = fitObj.invGausStats.confBoundSig;
            handle=[];
<span class="comment">%              for i=1:colm</span>
<span class="comment">%                     %i</span>
<span class="comment">%                     htemp=plot(lags',rho(:,i),strcat('.',FitResults.colors{mod(i-1,length(Analysis.colors))+1}));</span>
<span class="comment">%                     handle=[handle,htemp];</span>
<span class="comment">%                     hold on;</span>
<span class="comment">%                     %labelArray{i} = ['Fit ' num2str(i)];</span>
<span class="comment">%              end</span>

            rhoSig.plot;
            legend(fitObj.lambda.dataLabels,<span class="string">'Location'</span>,<span class="string">'Best'</span>);
            <span class="comment">%legend(h,labelArray);</span>
            hold <span class="string">on</span>; confBoundSig.plot;

        <span class="keyword">end</span>
        <span class="keyword">function</span> handle = plotResidual(fitObj)
            <span class="comment">% handle = plotResidual(fitObj)</span>
            <span class="comment">% Plots the Point Process Residual</span>
            handle=fitObj.Residual.plot;
            legend <span class="string">off</span>;
            legend(fitObj.Residual.dataLabels,<span class="string">'Location'</span>,<span class="string">'Best'</span>);
        <span class="keyword">end</span>


        <span class="keyword">function</span> setKSStats(fitObj, Z, U, xAxis, KSSorted, ks_stat)
            <span class="comment">% setKSStats(fitObj, Z, xAxis, KSSorted, ks_stat)</span>
            <span class="comment">% Allows KS statistics to be set after object creation</span>
            <span class="comment">% Z: Rescaled ISIs from the Time Rescaling Theorem</span>
            <span class="comment">% xAxis: xAxis of the KS plot</span>
            <span class="comment">% KSSorted: the sorted values of Uj=1-exp(-zj)</span>
            <span class="comment">% ks_stat: the maximum deviation from the 45 degree line for</span>
            <span class="comment">% all of the fits.</span>
            <span class="comment">%</span>
            fitObj.Z        =Z;
            fitObj.U        =U;
            fitObj.KSStats.xAxis    =xAxis;
            fitObj.KSStats.KSSorted =KSSorted;
            fitObj.KSStats.ks_stat  =ks_stat;
            N = length(fitObj.KSStats.KSSorted);
            fitObj.KSStats.withinConfInt = ks_stat&lt;1.36/sqrt(N);
        <span class="keyword">end</span>
        <span class="keyword">function</span> setInvGausStats(fitObj, X,rhoSig,confBoundSig)
            <span class="comment">% setInvGausStats(fitObj,X,rhoSig,confBoundSig)</span>
            <span class="comment">% Sets the inverse gaussian transformed rescaled ISIs and the</span>
            <span class="comment">% confidence bounds after the object has been created.</span>
            <span class="comment">%fitObj.U=U;</span>
            fitObj.X=X;
            fitObj.invGausStats.rhoSig=rhoSig;
            fitObj.invGausStats.confBoundSig=confBoundSig;
        <span class="keyword">end</span>
        <span class="keyword">function</span> setFitResidual(fitObj,M)
           <span class="comment">% setFitResidual(fitObj,M).</span>
           <span class="comment">% Adds the point process residual to the FitResult object</span>
           fitObj.Residual = M;
        <span class="keyword">end</span>



    <span class="keyword">end</span>

    <span class="keyword">methods</span> (Static)

        <span class="keyword">function</span> fitObj = fromStructure(structure)
            <span class="keyword">if</span>(isa(structure,<span class="string">'struct'</span>))
                spikeObj=nspikeTrain.fromStructure(structure.neuralSpikeTrain);
                lambda=Covariate.fromStructure(structure.lambda);
                rhoSig=SignalObj.signalFromStruct(structure.invGausStats.rhoSig);
                confBoundSig = SignalObj.signalFromStruct(structure.invGausStats.confBoundSig);
                M = Covariate.fromStructure(structure.Residual);
                <span class="keyword">for</span> i=1:structure.numResults
                    histObjects{i} = History.fromStructure(structure.histObjects{i});
                    ensHistObject{i} = History.fromStructure(structure.ensHistObjects{i});
                <span class="keyword">end</span>
                configColl = ConfigColl.fromStructure(structure.configs);
                fitObj=FitResult(spikeObj,structure.covLabels,structure.numHist,histObjects,ensHistObject,lambda,structure.b, structure.dev, structure.stats,structure.AIC,structure.BIC,configColl,structure.XvalData,structure.XvalTime,structure.fitType);
                fitObj.setKSStats(structure.Z,structure.U, structure.KSStats.xAxis, structure.KSStats.KSSorted, structure.KSStats.ks_stat);
                fitObj.setInvGausStats(structure.X,rhoSig,confBoundSig);
                fitObj.setFitResidual(M);
            <span class="keyword">elseif</span>(isa(structure,<span class="string">'cell'</span>)) <span class="comment">%cell array of FitResult objects</span>
                fitObj = cell(size(structure));
               <span class="keyword">for</span> i=1:length(structure)
                  fitObj{i} = FitResult.fromStructure(structure{i});
               <span class="keyword">end</span>
            <span class="keyword">end</span>

        <span class="keyword">end</span>

        <span class="keyword">function</span> structCell = CellArrayToStructure(fitResObjCell)
           <span class="keyword">if</span>(isa(fitResObjCell,<span class="string">'FitResult'</span>))
               structCell = fitResObjCell.toStructure;
           <span class="keyword">elseif</span>(isa(fitResObjCell,<span class="string">'cell'</span>))
               <span class="keyword">if</span>(isa(fitResObjCell{1},<span class="string">'FitResult'</span>))
                   structCell = cell(size(fitResObjCell));
                  <span class="keyword">for</span> i=1:length(fitResObjCell)
                     structCell{i} = fitResObjCell{i}.toStructure;
                  <span class="keyword">end</span>
               <span class="keyword">end</span>
           <span class="keyword">end</span>

        <span class="keyword">end</span>

    <span class="keyword">end</span>

<span class="keyword">end</span>

<span class="comment">%Helper functions</span>
<span class="keyword">function</span> hText = xticklabel_rotate(XTick,rot,varargin)
    <span class="comment">%hText = xticklabel_rotate(XTick,rot,XTickLabel,varargin)     Rotate XTickLabel</span>
    <span class="comment">%</span>
    <span class="comment">% Syntax: xticklabel_rotate</span>
    <span class="comment">%</span>
    <span class="comment">% Input:</span>
    <span class="comment">% {opt}     XTick       - vector array of XTick positions &amp; values (numeric)</span>
    <span class="comment">%                           uses current XTick values or XTickLabel cell array by</span>
    <span class="comment">%                           default (if empty)</span>
    <span class="comment">% {opt}     rot         - angle of rotation in degrees, 90&deg; by default</span>
    <span class="comment">% {opt}     XTickLabel  - cell array of label strings</span>
    <span class="comment">% {opt}     [var]       - "Property-value" pairs passed to text generator</span>
    <span class="comment">%                           ex: 'interpreter','none'</span>
    <span class="comment">%                               'Color','m','Fontweight','bold'</span>
    <span class="comment">%</span>
    <span class="comment">% Output:   hText       - handle vector to text labels</span>
    <span class="comment">%</span>
    <span class="comment">% Example 1:  Rotate existing XTickLabels at their current position by 90&deg;</span>
    <span class="comment">%    xticklabel_rotate</span>
    <span class="comment">%</span>
    <span class="comment">% Example 2:  Rotate existing XTickLabels at their current position by 45&deg; and change</span>
    <span class="comment">% font size</span>
    <span class="comment">%    xticklabel_rotate([],45,[],'Fontsize',14)</span>
    <span class="comment">%</span>
    <span class="comment">% Example 3:  Set the positions of the XTicks and rotate them 90&deg;</span>
    <span class="comment">%    figure;  plot([1960:2004],randn(45,1)); xlim([1960 2004]);</span>
    <span class="comment">%    xticklabel_rotate([1960:2:2004]);</span>
    <span class="comment">%</span>
    <span class="comment">% Example 4:  Use text labels at XTick positions rotated 45&deg; without tex interpreter</span>
    <span class="comment">%    xticklabel_rotate(XTick,45,NameFields,'interpreter','none');</span>
    <span class="comment">%</span>
    <span class="comment">% Example 5:  Use text labels rotated 90&deg; at current positions</span>
    <span class="comment">%    xticklabel_rotate([],90,NameFields);</span>
    <span class="comment">%</span>
    <span class="comment">% Note : you can not re-run xticklabel_rotate on the same graph.</span>
    <span class="comment">%</span>
    <span class="comment">%</span>


    <span class="comment">% This is a modified version of xticklabel_rotate90 by Denis Gilbert</span>
    <span class="comment">% Modifications include Text labels (in the form of cell array)</span>
    <span class="comment">%                       Arbitrary angle rotation</span>
    <span class="comment">%                       Output of text handles</span>
    <span class="comment">%                       Resizing of axes and title/xlabel/ylabel positions to maintain same overall size</span>
    <span class="comment">%                           and keep text on plot</span>
    <span class="comment">%                           (handles small window resizing after, but not well due to proportional placement with</span>
    <span class="comment">%                           fixed font size. To fix this would require a serious resize function)</span>
    <span class="comment">%                       Uses current XTick by default</span>
    <span class="comment">%                       Uses current XTickLabel is different from XTick values (meaning has been already defined)</span>

    <span class="comment">% Brian FG Katz</span>
    <span class="comment">% bfgkatz@hotmail.com</span>
    <span class="comment">% 23-05-03</span>
    <span class="comment">% Modified 03-11-06 after user comment</span>
    <span class="comment">%	Allow for exisiting XTickLabel cell array</span>

    <span class="comment">% Other m-files required: cell2mat</span>
    <span class="comment">% Subfunctions: none</span>
    <span class="comment">% MAT-files required: none</span>
    <span class="comment">%</span>
    <span class="comment">% See also: xticklabel_rotate90, TEXT,  SET</span>

    <span class="comment">% Based on xticklabel_rotate90</span>
    <span class="comment">%   Author: Denis Gilbert, Ph.D., physical oceanography</span>
    <span class="comment">%   Maurice Lamontagne Institute, Dept. of Fisheries and Oceans Canada</span>
    <span class="comment">%   email: gilbertd@dfo-mpo.gc.ca  Web: http://www.qc.dfo-mpo.gc.ca/iml/</span>
    <span class="comment">%   February 1998; Last revision: 24-Mar-2003</span>

    <span class="comment">% check to see if xticklabel_rotate has already been here (no other reason for this to happen)</span>
    <span class="keyword">if</span> isempty(get(gca,<span class="string">'XTickLabel'</span>)),
        error(<span class="string">'xticklabel_rotate : can not process, either xticklabel_rotate has already been run or XTickLabel field has been erased'</span>)  ;
    <span class="keyword">end</span>

    <span class="comment">% if no XTickLabel AND no XTick are defined use the current XTickLabel</span>
    <span class="comment">%if nargin &lt; 3 &amp; (~exist('XTick') | isempty(XTick)),</span>
    <span class="keyword">if</span> (nargin &lt; 3 || isempty(varargin{1})) &amp; (~exist(<span class="string">'XTick'</span>) | isempty(XTick)),
        xTickLabels = get(gca,<span class="string">'XTickLabel'</span>)  ; <span class="comment">% use current XTickLabel</span>
        <span class="keyword">if</span> ~iscell(xTickLabels)
            <span class="comment">% remove trailing spaces if exist (typical with auto generated XTickLabel)</span>
            temp1 = num2cell(xTickLabels,2)         ;
            <span class="keyword">for</span> loop = 1:length(temp1),
                temp1{loop} = deblank(temp1{loop})  ;
            <span class="keyword">end</span>
            xTickLabels = temp1                     ;
        <span class="keyword">end</span>
    varargin = varargin(2:length(varargin));
    <span class="keyword">end</span>

    <span class="comment">% if no XTick is defined use the current XTick</span>
    <span class="keyword">if</span> (~exist(<span class="string">'XTick'</span>) | isempty(XTick)),
        XTick = get(gca,<span class="string">'XTick'</span>)        ; <span class="comment">% use current XTick</span>
    <span class="keyword">end</span>

    <span class="comment">%Make XTick a column vector</span>
    XTick = XTick(:);

    <span class="keyword">if</span> ~exist(<span class="string">'xTickLabels'</span>),
        <span class="comment">% Define the xtickLabels</span>
        <span class="comment">% If XtickLabel is passed as a cell array then use the text</span>
        <span class="keyword">if</span> (length(varargin)&gt;0) &amp; (iscell(varargin{1})),
            xTickLabels = varargin{1};
            varargin = varargin(2:length(varargin));
        <span class="keyword">else</span>
            xTickLabels = num2str(XTick);
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">if</span> length(XTick) ~= length(xTickLabels),
        error(<span class="string">'xticklabel_rotate : must have same number of elements in "XTick" and "XTickLabel"'</span>)  ;
    <span class="keyword">end</span>

    <span class="comment">%Set the Xtick locations and set XTicklabel to an empty string</span>
    set(gca,<span class="string">'XTick'</span>,XTick,<span class="string">'XTickLabel'</span>,<span class="string">''</span>)

    <span class="keyword">if</span> nargin &lt; 2,
        rot = 90 ;
    <span class="keyword">end</span>

    <span class="comment">% Determine the location of the labels based on the position</span>
    <span class="comment">% of the xlabel</span>
    hxLabel = get(gca,<span class="string">'XLabel'</span>);  <span class="comment">% Handle to xlabel</span>
    xLabelString = get(hxLabel,<span class="string">'String'</span>);

    <span class="comment">% if ~isempty(xLabelString)</span>
    <span class="comment">%    warning('You may need to manually reset the XLABEL vertical position')</span>
    <span class="comment">% end</span>

    set(hxLabel,<span class="string">'Units'</span>,<span class="string">'data'</span>);
    xLabelPosition = get(hxLabel,<span class="string">'Position'</span>);
    y = xLabelPosition(2);

    <span class="comment">%CODE below was modified following suggestions from Urs Schwarz</span>
    y=repmat(y,size(XTick,1),1);
    <span class="comment">% retrieve current axis' fontsize</span>
    fs = get(gca,<span class="string">'fontsize'</span>);

    <span class="comment">% Place the new xTickLabels by creating TEXT objects</span>
    hText = text(XTick, y, xTickLabels,<span class="string">'fontsize'</span>,fs);

    <span class="comment">% Rotate the text objects by ROT degrees</span>
    set(hText,<span class="string">'Rotation'</span>,rot,<span class="string">'HorizontalAlignment'</span>,<span class="string">'right'</span>,varargin{:})

    <span class="comment">% Adjust the size of the axis to accomodate for longest label (like if they are text ones)</span>
    <span class="comment">% This approach keeps the top of the graph at the same place and tries to keep xlabel at the same place</span>
    <span class="comment">% This approach keeps the right side of the graph at the same place</span>

    set(get(gca,<span class="string">'xlabel'</span>),<span class="string">'units'</span>,<span class="string">'data'</span>)           ;
        labxorigpos_data = get(get(gca,<span class="string">'xlabel'</span>),<span class="string">'position'</span>)  ;
    set(get(gca,<span class="string">'ylabel'</span>),<span class="string">'units'</span>,<span class="string">'data'</span>)           ;
        labyorigpos_data = get(get(gca,<span class="string">'ylabel'</span>),<span class="string">'position'</span>)  ;
    set(get(gca,<span class="string">'title'</span>),<span class="string">'units'</span>,<span class="string">'data'</span>)           ;
        labtorigpos_data = get(get(gca,<span class="string">'title'</span>),<span class="string">'position'</span>)  ;

    set(gca,<span class="string">'units'</span>,<span class="string">'pixel'</span>)                        ;
    set(hText,<span class="string">'units'</span>,<span class="string">'pixel'</span>)                      ;
    set(get(gca,<span class="string">'xlabel'</span>),<span class="string">'units'</span>,<span class="string">'pixel'</span>)          ;
    set(get(gca,<span class="string">'ylabel'</span>),<span class="string">'units'</span>,<span class="string">'pixel'</span>)          ;

    origpos = get(gca,<span class="string">'position'</span>)                   ;
    textsizes = cell2mat(get(hText,<span class="string">'extent'</span>))       ;
    longest =  max(textsizes(:,4))                  ;

    laborigext = get(get(gca,<span class="string">'xlabel'</span>),<span class="string">'extent'</span>)    ;
    laborigpos = get(get(gca,<span class="string">'xlabel'</span>),<span class="string">'position'</span>)  ;


    labyorigext = get(get(gca,<span class="string">'ylabel'</span>),<span class="string">'extent'</span>)   ;
    labyorigpos = get(get(gca,<span class="string">'ylabel'</span>),<span class="string">'position'</span>) ;
    leftlabdist = labyorigpos(1) + labyorigext(1)   ;

    <span class="comment">% assume first entry is the farthest left</span>
    leftpos = get(hText(1),<span class="string">'position'</span>)              ;
    leftext = get(hText(1),<span class="string">'extent'</span>)                ;
    leftdist = leftpos(1) + leftext(1)              ;
    <span class="keyword">if</span> leftdist &gt; 0,    leftdist = 0 ; <span class="keyword">end</span>          <span class="comment">% only correct for off screen problems</span>

    botdist = origpos(2) + laborigpos(2)            ;
    newpos = [origpos(1)-leftdist longest+botdist origpos(3)+leftdist origpos(4)-longest+origpos(2)-botdist]  ;
    set(gca,<span class="string">'position'</span>,newpos)                      ;

    <span class="comment">% readjust position of nex labels after resize of plot</span>
    set(hText,<span class="string">'units'</span>,<span class="string">'data'</span>)                       ;
    <span class="keyword">for</span> loop= 1:length(hText),
        set(hText(loop),<span class="string">'position'</span>,[XTick(loop), y(loop)])  ;
    <span class="keyword">end</span>


    <span class="comment">% adjust position of xlabel and ylabel</span>
    laborigpos = get(get(gca,<span class="string">'xlabel'</span>),<span class="string">'position'</span>)  ;
    set(get(gca,<span class="string">'xlabel'</span>),<span class="string">'position'</span>,[laborigpos(1) laborigpos(2)-longest 0])   ;

    <span class="comment">% switch to data coord and fix it all</span>
    set(get(gca,<span class="string">'ylabel'</span>),<span class="string">'units'</span>,<span class="string">'data'</span>)                   ;
    set(get(gca,<span class="string">'ylabel'</span>),<span class="string">'position'</span>,labyorigpos_data)      ;
    set(get(gca,<span class="string">'title'</span>),<span class="string">'position'</span>,labtorigpos_data)       ;

    set(get(gca,<span class="string">'xlabel'</span>),<span class="string">'units'</span>,<span class="string">'data'</span>)                   ;
        labxorigpos_data_new = get(get(gca,<span class="string">'xlabel'</span>),<span class="string">'position'</span>)  ;
    set(get(gca,<span class="string">'xlabel'</span>),<span class="string">'position'</span>,[labxorigpos_data(1) labxorigpos_data_new(2)])   ;


    <span class="comment">% Reset all units to normalized to allow future resizing</span>
    set(get(gca,<span class="string">'xlabel'</span>),<span class="string">'units'</span>,<span class="string">'normalized'</span>)          ;
    set(get(gca,<span class="string">'ylabel'</span>),<span class="string">'units'</span>,<span class="string">'normalized'</span>)          ;
    set(get(gca,<span class="string">'title'</span>),<span class="string">'units'</span>,<span class="string">'normalized'</span>)          ;
    set(hText,<span class="string">'units'</span>,<span class="string">'normalized'</span>)                      ;
    set(gca,<span class="string">'units'</span>,<span class="string">'normalized'</span>)                        ;

    <span class="keyword">if</span> nargout &lt; 1,
        clear <span class="string">hText</span>
    <span class="keyword">end</span>

<span class="keyword">end</span>
<span class="keyword">function</span> [uniqueLabels, indexIntoOriginal, restoreIndex] = getUniqueLabels(covLabels)
            offset = 0;
            <span class="keyword">for</span> i=1:length(covLabels)
                currLabels = covLabels{i};
                allLabels((1:length(currLabels))+offset) = currLabels;
                offset=length(allLabels);
            <span class="keyword">end</span>
            [uniqueLabels, indexIntoOriginal, restoreIndex] = unique(allLabels);
<span class="keyword">end</span>
</pre><pre class="codeoutput">Input argument "spikeObj" is undefined.

Error in ==&gt; FitResult&gt;FitResult.FitResult at 86
            if(isnumeric(spikeObj.name))
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.11<br></p></div><!--
##### SOURCE BEGIN #####
classdef FitResult < handle
    % FITRESULT 
    % stores results of a fit using the Analysis object
    % The results are for a single neuron over a range of configurations
    % <a href="matlab:web('FitResultExamples.html', '-helpbrowser')">FitResult Examples</a> 
    % see also <a href="matlab:help('Analysis')">Analysis</a>
    % Reference page in Help browser
    % <a href="matlab:doc('FitResult')">doc FitResult</a>
    properties
       numResults   %Number of results in this FitResult object
       lambda       %Lambda signal
       numCoeffs    %Number of coefficients for each fitResult
       fitType      %Poisson or Binomial
       
       b            %coefficients for each fit
       dev          %deviance for each fit
       AIC          %Akaike's Information Criterion for each fit
       BIC          %Baysian Information Criterion for each fit
       stats        %Relevant statistics for each fit
       configs      % the config collection for the different fits
       configNames  % names of the the differen fits
       neuronNumber % the number of the neuron the data comes from
       neuralSpikeTrain % the spike data
       covLabels    
       uniqueCovLabels
       indicesToUniqueLabels
       numHist        % Number of history terms (used for indexing into the regression coefficients) for each fit
       histObjects    % History object for self firing 
       ensHistObjects % History object to be applied to the neuron's neigbors to compute ensemble effect
       flatMask
       Z    % Rescaled spike times from the Time-Rescaling theorem, exponential rate 1
       U    % Transformed z's -> uniform in [0,1]
       X    % Transformed u's -> gaussian in [-inf, inf]
       Residual %fit residual
%        xAxis
%        KSSorted
%        ks_stat
       invGausStats 
       KSStats  %Kolmogorov Smirnov Statistics
       plotParams
       XvalData % cell array of raw data used for validation
       XvalTime % cell array of time vectors for each element of XvalData
       validation % a FitResult object with the validation data
       minTime  % The minTime from the spikeTrain (not necessarily the analysis)
       maxTime  % The maxTime for the spikeTrain (not necessarily the analysis)
    end
    properties (Constant,Hidden)
        colors={'b','g','r','c','m','y','k'};    
    end


    methods 
     
        function fitObj=FitResult(spikeObj,covLabels,numHist,histObjects,ensHistObj,lambda,b, dev, stats,AIC,BIC,configColl,XvalData,XvalTime,distribution)
            % fitObj=FitResult(spikeObj,covLabels,numHist,histObjects,ensHistObj,lambda,b, dev, stats,AIC,BIC,configColl,XvalData,XvalTime)
            % Stores the results of multiple regressions for a single  neuron into a accessible structure.
            %
            % spikeObj: The spike train for the neuron whose results are
            %           being stored.
            % covLabels: A 2-d cell array, the jth row has all the labels for the covariates used in the jth fit
            % numHist: The number of history terms in each of the N fits.
            % histObjects: The History object for each of the N fits
            % ensHistObj: The History object for used to compute the ensemble history effect.
            % lambda: The conditional intensity function evaluated usin the
            % data. Each dimension of lambda corresponds to the a different
            %       GLM Fit.
            % b: N-component cell array containing the GLM regression
            %    coefficient of each of the fits. The jth component has all
            %    the regression coefficients for the jth trial.
            % dev: vector of Deviances for each the GLM fits.
            % stats: Cell array of the stats parameters for each GLM fit;
            % AIC: vector of Akaike's information criteria for each the GLM fits.
            % BIC: vector of Bayes Information criteria for each the GLM fits.
            % configColl: configCollection object used to generate this
            %             results
            % XvalData: Data to be used for validation.
            % XvalTime: Time vector for the data.
            
            if(nargin< 14)
                XvalTime =[];
            end
            if(nargin<13)
                XvalData =[];
            end
            
            if(isnumeric(spikeObj.name))
                nNumber =spikeObj.name;
            else
                nNumber = str2double(spikeObj.name(~isletter(spikeObj.name)));
            end
            fitObj.neuronNumber = nNumber; %str2num(spikeObj.name);
            fitObj.neuralSpikeTrain = spikeObj;
            fitObj.minTime = spikeObj.minTime;
            fitObj.maxTime = spikeObj.maxTime;
            fitObj.numResults = 0;
            fitObj.configs = configColl;
            fitObj.configNames = configColl.getConfigNames;
            fitObj.covLabels=covLabels;
            fitObj.uniqueCovLabels= getUniqueLabels(covLabels);
           
            fitObj.mapCovLabelsToUniqueLabels;
            fitObj.numHist=numHist;
            fitObj.histObjects = histObjects;
            fitObj.ensHistObjects = ensHistObj;
            fitObj.addParamsToFit(fitObj.neuronNumber,lambda,b, dev, stats,AIC,BIC,configColl);
            fitObj.Z        =[]; %rescaled spikes times - exponentially dist.
            fitObj.U        =[]; %rescaled spike times - uniformly dist.
            fitObj.X        =[]; %rescaled spike times - gaussian dist.
            fitObj.Residual =[]; %fit residual for PP
            fitObj.KSStats.xAxis    =[];
            fitObj.KSStats.KSSorted =[];
            fitObj.KSStats.ks_stat  =[];
            fitObj.invGausStats.rhoSig=[];
            fitObj.invGausStats.confBoundSig=[];
            fitObj.plotParams = [];
            fitObj.XvalData = XvalData;
            fitObj.XvalTime = XvalTime;     
            
            fitObj.fitType = distribution;     
             
        end        
        function mFitRes = mergeResults(fitObj,newFitObj)
            if(isa(newFitObj,'FitResult'))
                if(fitObj.neuronNumber ==newFitObj.neuronNumber)
                    spikeObj = fitObj.neuralSpikeTrain;
                    covLabels = fitObj.covLabels(1:fitObj.numResults);
                    covLabels((fitObj.numResults+1):(fitObj.numResults+newFitObj.numResults)) = newFitObj.covLabels(1:newFitObj.numResults);
                    numHist = fitObj.numHist(1:fitObj.numResults);
                    numHist((fitObj.numResults+1):(fitObj.numResults+newFitObj.numResults)) = newFitObj.numHist(1:newFitObj.numResults);
                    histObjects=fitObj.histObjects(1:fitObj.numResults);
                    histObjects((fitObj.numResults+1):(fitObj.numResults+newFitObj.numResults)) = newFitObj.histObjects(1:newFitObj.numResults);
                    ensHistObjects=fitObj.ensHistObjects(1:fitObj.numResults);
                    ensHistObjects((fitObj.numResults+1):(fitObj.numResults+newFitObj.numResults)) = newFitObj.ensHistObjects(1:newFitObj.numResults);
                    b=fitObj.b(1:fitObj.numResults);
                    b((fitObj.numResults+1):(fitObj.numResults+newFitObj.numResults)) = newFitObj.b(1:newFitObj.numResults);
                    dev = [fitObj.dev newFitObj.dev];
                    AIC = [fitObj.AIC newFitObj.AIC];
                    BIC = [fitObj.BIC newFitObj.BIC];
                    stats=fitObj.stats(1:fitObj.numResults);
                    stats((fitObj.numResults+1):(fitObj.numResults+newFitObj.numResults)) = newFitObj.stats(1:newFitObj.numResults);
                    lambda = fitObj.lambda.merge(newFitObj.lambda);
                    
                    for i=1:fitObj.numResults
                        config{i}=fitObj.configs.getConfig(i);
                    end
                    offset=fitObj.numResults;
                    for i=1:newFitObj.numResults
                        config{i+offset}=newFitObj.configs.getConfig(i);
                    end
                    configColl= ConfigColl(config);
                    
                    XvalData = [fitObj.XvalData newFitObj.XvalData];
                    XvalTime = [fitObj.XvalTime newFitObj.XvalTime];
                    distribution=fitObj.fitType(1:fitObj.numResults);
                    distribution((fitObj.numResults+1):(fitObj.numResults+newFitObj.numResults)) = newFitObj.fitType(1:newFitObj.numResults);
                    Z=[fitObj.Z newFitObj.Z];
                    U=[fitObj.U newFitObj.U];
                    [X,rhoSig,confBoundSig] = Analysis.computeInvGausTrans(Z);

                    M=fitObj.Residual.merge(newFitObj.Residual);
                    xAxis    = [fitObj.KSStats.xAxis newFitObj.KSStats.xAxis];
                    KSSorted = [fitObj.KSStats.KSSorted newFitObj.KSStats.KSSorted];
                    ks_stat  = [fitObj.KSStats.ks_stat newFitObj.KSStats.ks_stat];
                    mFitRes=FitResult(spikeObj,covLabels,numHist,histObjects,ensHistObjects,lambda,b, dev, stats,AIC,BIC,configColl,XvalData,XvalTime,distribution);
                    mFitRes.setKSStats(Z,U, xAxis, KSSorted, ks_stat);
                    mFitRes.setInvGausStats(X,rhoSig,confBoundSig);
                    mFitRes.setFitResidual(M);
                    
                    
                elseif(isa(newFitObj,'cell'))
                    if(isa(newFitObj{1},'FitResult'))
                        for i=1:length(newFitObj)
                            if(i==1)
                                mFitRes = fitObj.mergeResults(newFitObj{i});
                            else
                                mFitRes = mFitRes.mergeResults(newFitObj{i});
                            end
                        end
                    end
                end
            end
            
        end
        function addParamsToFit(fitObj,neuronNum,lambda,b, dev, stats,AIC,BIC,configColl)
            % addParamsToFit(fitObj,neuronNum,lambda,b, dev, stats,AIC,BIC,configColl)
            % Add the specified parameters to the current FitResult object
            % only if the neuronNum matches the neuronNum of this object
            if(fitObj.neuronNumber==neuronNum)
              if(isa(lambda,'cell'))
                  newLambda=lambda{1};
                  for i=2:length(lambda)
                      newLambda = newLambda.merge(lambda{i});
                  end
              elseif(isa(lambda,'Covariate')||isa(lambda,'SignalObj'))
                  newLambda = lambda;
              end

              numNewResults = newLambda.dimension;%number of new elements
              if(nargin<8)
                  configColl = cell(1,numNewResults);
              end

              if(numNewResults==1)
                      fitObj.b{fitObj.numResults+1}    = b{1};
                      fitObj.dev(fitObj.numResults+1)  = dev;
                      fitObj.stats{fitObj.numResults+1}= stats{1};
                      if(nargin<7)
                          fitObj.AIC(fitObj.numResults+1)  = 2*length(b)+dev;
                          fitObj.BIC(fitObj.numResults+1)  = length(b)*log(length(newLambda.time))+dev;
                      else
                          fitObj.AIC(fitObj.numResults+1)  = AIC;
                          fitObj.BIC(fitObj.numResults+1)  = BIC;
                      end
                          
                      fitObj.numCoeffs(fitObj.numResults+1) = length(b);
              else
                  for i=1:numNewResults
                      fitObj.b{fitObj.numResults+i}    = b{i};
                      fitObj.dev(fitObj.numResults+i)  = dev(i);
                      fitObj.stats{fitObj.numResults+i}= stats{i};
                      if(nargin<7)
                          fitObj.AIC(fitObj.numResults+i)  = 2*length(b{i})+dev(i);
                          fitObj.BIC(fitObj.numResults+i)  = length(b{i})*log(length(newLambda.time))+dev(i);
                      else
                          fitObj.AIC(fitObj.numResults+i)  = AIC(i);
                          fitObj.BIC(fitObj.numResults+i)  = BIC(i);
                      end
                      fitObj.numCoeffs(fitObj.numResults+i) = length(b{i});
                  end
              end
              if(fitObj.numResults ==0)
                  fitObj.lambda = newLambda;
              else
                fitObj.lambda = fitObj.lambda.merge(newLambda); %new lambda
              end
              
              fitObj.numResults = fitObj.numResults+numNewResults;
              dataLabels = cell(1,fitObj.numResults);
              for i=1:fitObj.numResults
                 dataLabels{i} = strcat('\lambda_',num2str(i));
              end
              fitObj.lambda.setDataLabels(dataLabels);
              
              fitObj.configs.addConfig(configColl);
              fitObj.configNames = fitObj.configs.getConfigNames;
          else
              error('Neuron number does not match');
          end
        end
        function lambda = computeValLambda(fitObj)
            % lambda = computeValLambda(fitObj)
            % Returns a Covariate object lambda. This is the Conditional
            % intensity function evaluated using the validation data
            lambdaData = zeros(length(fitObj.XvalTime{1}),fitObj.numResults);
            for i=1:fitObj.numResults
                lambdaData(:,i) = fitObj.evalLambda(i,fitObj.XvalData{i});
            end
            lambda=Covariate(fitObj.XvalTime{1},lambdaData,...
                  '\Lambda(t)',fitObj.lambda.xlabelval,...
                  fitObj.lambda.xunits,'Hz',fitObj.lambda.dataLabels);
        end
        
        function mapCovLabelsToUniqueLabels(fitObj)
            flatMask = zeros(length(fitObj.uniqueCovLabels),length(fitObj.covLabels));
            for j=1:length(fitObj.covLabels)
                currLabels = fitObj.covLabels{j};
                index=zeros(1,length(currLabels));
                for i=1:length(currLabels)
                    index(i)=strmatch(currLabels{i}, fitObj.uniqueCovLabels, 'exact');
                end
                
                fitObj.indicesToUniqueLabels{j} = index;
                flatMask(index,j) = 1;
            end
            fitObj.flatMask = flatMask;
        end        
        function p=getPlotParams(fitObj)
            % p=getPlotParams(fitObj)
            if(isempty(fitObj.plotParams))
                fitObj.computePlotParams;
            end
                p=fitObj.plotParams;
        end        
        function plotValidation(fitObj) 
            % plotValidation(fitObj) 
            % calls plotResults on the validation FitResult object if
            % validation data is present. Note that the GLM coefficients
            % are not recomputed and therefore the same as those obtained
            % from the training data.
            if(~isempty(fitObj.validation))
                fitObj.validation.plotResults;
            else
                display('Validation Data not available to plot');
            end
        end
        function answer = isValDataPresent(fitObj)
            % answer = isValDataPresent(fitObj)
            % returns 1 if validation data is present. This method is used
            % to determine if validation data is available to compute the
            % validation results.
            answer = 0;
            if(~isempty(fitObj.XvalTime) && ~isempty(fitObj.XvalData))
                for i=1:length(fitObj.XvalTime)
                    currTime = fitObj.XvalTime{i};
                    if(~isempty(currTime))
                        if(currTime(end)-currTime(1)>0)
                            answer =1;
                            break;
                        end
                    end
                end
                
            end
            
        end        
        function lambdaData = evalLambda(fitObj,lambdaIndex,newData)
            % lambdaData = evalLambda(fitObj,lambdaIndex,newData)
            % lambdaIndex: the index of the corresponding lambda to be
            %              evaluated with the new data.
            % newData:     matrix of covariates in same order as fits without
            %              constant term in first column
%             if(isa(newData,'double'))
%                 [~,columns] = size(newData);
%                 tempData = cell(1,columns);
%                 for i=1:columns
%                    tempData{i} = newData(:,i); 
%                 end
%                 newData = tempData;
%             end
            
            if(lambdaIndex>0 && lambdaIndex <= fitObj.numResults)
                b=fitObj.b{lambdaIndex}; %coefficient matrix
                if(isempty(newData))
                    [rows,~] = size(newData);
                    baseline=ones(rows,1);
                    lambdaData =  exp(b(1)*baseline);
                else
                    if(isa(newData,'double')) %matrix, 1 column per coefficient
                        baseline=ones(length(newData),1);
                        [~,columns] = size(newData);
                        
                        if(length(b)>=1)
                            lambdaData = exp(newData*b(1:end));
                            if(strcmp(fitObj.fitType{lambdaIndex},'poisson'))
%                                 lambdaData = exp(newData*b(1:end));
%                                 lambdaData = exp(b(1) + newData*b(2:end));
                            else 
%                                 lambdaData = exp(b(1) + newData*b(2:end));
                                lambdaData = lambdaData./(1+lambdaData);
                            end
%                         else
%                             if(strcmp(fitObj.fitType{lambdaIndex},'poisson'))
%                                 lambdaData = exp(b(1)*baseline);
%                                 
%                             else
%                                 lambdaData = exp(b(1)*baseline);
%                                 lambdaData = lambdaData./(1+lambdaData);
%                             end
                        end
                        lambdaData = lambdaData*fitObj.neuralSpikeTrain.sampleRate;
                    elseif(isa(newData,'cell')) % a cell array, each element is matrix of values for each coeff
%                         baseline=ones(size(newData{1})); %design matrix
                            runSum=0;
                        for i=1:(length(newData)) %-fitObj.numHist(lambdaIndex))
%                             if(i==1)
%                                 runSum = b(1)*baseline;
%                             else
                                runSum = runSum+b(i)*newData{i-1};
%                             end
                        end
                        if(strcmp(fitObj.fitType{lambdaIndex},'poisson'))
                            lambdaData = exp(runSum);
                            lambdaData = lambdaData*fitObj.neuralSpikeTrain.sampleRate;
                        else
                            lambdaData = exp(runSum);
                            lambdaData = lambdaData./(1+lambdaData);
                            lambdaData = lambdaData*fitObj.neuralSpikeTrain.sampleRate;
                        end
                    else
                        error('New data must be cell or a matrix');
                    end
                    
                end
            else
                error('Index into fit params is incorrect');
            end
            
        end        
%         function handle = plotHist(fitObj,fitNum)
%            % handle = plotHist(fitObj,fitNum)
%            % plots the history terms used in this FitResult object
%            % if fitNum is not specified then fitNum=1:numResults
%            if(nargin<2 || isempty(fitNum))
%                fitNum = 1:fitObj.numResults;
%            end
%            
%            for j=fitNum
%                if(j>0 && j <= fitObj.numResults)
%                     b=fitObj.b{j}; %coefficient matrix
%                     startHistIndex = length(b)-fitObj.numHist(j)+1;
%                     if(startHistIndex<length(b))
%                         bHist = b(startHistIndex:end);
%                         if(~isempty(fitObj.histObjects{j}))
%                             windowTimes = fitObj.histObjects{j}.windowTimes;
%                             t=linspace(windowTimes(1),windowTimes(end),100)';
%                             histEffect = zeros(length(t),1);
%                             for i=1:length(windowTimes)-1
%                                 index = and(t>=windowTimes(i),t<=windowTimes(i+1));
%                                 histEffect(index)=exp(-bHist(i))-1; %To offset zero coeffs
%                             end
%                         end
%                     else
%                         t=[0; 0.00001];
%                         histEffect =[0;0];
%                     end
%                     if(j==fitNum(1))
%                         hSig = SignalObj(t,histEffect,'History','time','s','',fitObj.lambda.dataLabels{j});
%                     else
%                         hSig = hSig.merge(SignalObj(t,histEffect,'History Effect','time','s','',fitObj.lambda.dataLabels{j}));
%                     end
%                end
%            end
%            N=floor(length(hSig.time)./70); B=ones(1,N)/N; A=1;
%            handle=hSig.filtfilt(B,A).plot;    
%         end
        function computePlotParams(fitObj,fitNum)
             if(nargin<2)
               fitNum = 1:fitObj.numResults;
             end
           index=find(sum(fitObj.flatMask,2)>0);%1:length(fitObj.flatMask(:,1));
           %Only use the labels that appear in at least one fit
           %Otherwise that parameter was not present for any of the
           %regressions and just takes up plot real-estate
           
           sigIndex=zeros(length(index),length(fitNum));
           bAct = nan(length(index),length(fitNum));
           seAct= nan(length(index),length(fitNum));
           
           for i=fitNum
               %this indexing is to avoid extremely large se's from
               %affecting plots
               criteria = find(fitObj.stats{i}.se'<100);
               %indicesForFit = find(fitObj.flatMask(index,i)==1);
               indicesForFit = fitObj.indicesToUniqueLabels{i};
               bVals = fitObj.b{i}(criteria);
               bAct(indicesForFit(criteria),i) = bVals; %sorted according to uniqueLabels
               seVals = fitObj.stats{i}.se(criteria)';
               seAct(indicesForFit(criteria),i)= seVals; %sorted according to uniqueLabels;
               temp = sign([bAct(:,i)-seAct(:,i) bAct(:,i)+seAct(:,i)]);
               productOfSigns = temp(:,1).*temp(:,2); %should be positive
               sIndex=and(productOfSigns>0,seAct(:,i)~=0);
               sigIndex(:,i)=sIndex;
           end
           fitObj.plotParams.bAct = bAct;
           fitObj.plotParams.seAct= seAct;
           fitObj.plotParams.sigIndex = sigIndex;
           fitObj.plotParams.xLabels  = cell(length(index),1);           
           fitObj.plotParams.xLabels = fitObj.uniqueCovLabels;
               
%            for i=1:(length(index))
%                if(i==1)
%                    fitObj.plotParams.xLabels{i} = 'baseline';
%                    %text(i, 0,'baseline','interpreter','latex');
%                else
%                    fitObj.plotParams.xLabels{i} = fitObj.covLabels{index(i)-1};
%                    %text(i, 0,fitObj.covLabels{index(i)-1},'interpreter','latex');
%                end
%            end
           tempVal =sum(fitObj.flatMask,2);
           fitObj.plotParams.numResultsCoeffPresent =tempVal(index); 
        end
        function h=plotCoeffs(fitObj,handle,fitNum,plotProps,plotSignificance)
           % h=plotCoeffs(fitObj,handle,fitNum,plotProps,plotSignificance)
           % plots the GLM coefficients for each fit along with the
           % confidence intervals. 
           % fitNum: number of the fit to plot. If not specified, all are
           %         plotted.
           % plotProps: properties to use for the making the plot
           % plotSignificance: If 1 then an asterix (*) is place above
           %                   parameters that are statistically different
           %                   from zero with alpha=5%.
           
           if(nargin<5)
               plotSignificance = 1;
           end
           
           if(nargin<4 || isempty(plotProps))
               plotProps = [];
           end
           
           if(nargin<3 || isempty(fitNum))
               fitNum = 1:fitObj.numResults;
           end
           
           if(nargin<2 || isempty(handle))
               handle=gca;
           end
           
           if(isempty(fitObj.plotParams))
               fitObj.computePlotParams(fitNum);
           end
              
           bAct = fitObj.getPlotParams.bAct;
           seAct= fitObj.getPlotParams.seAct;
           sigIndex=fitObj.getPlotParams.sigIndex;
           
           if(~isempty(plotProps))
               for i=1:length(fitNum)
                    h=errorbar(handle,1:length(index),bAct,seAct,plotProps{i}); hold on;
               end
           else
               Xaxis=repmat(1:length(bAct(:,1)),[length(bAct(1,:)) 1]);
               h=errorbar(handle,Xaxis',bAct,seAct,'.');%strcat('.',FitResult.colors{mod(i-1,length(FitResult.colors))+1})); 
           end

            hold on;
           
            
            if(plotSignificance==1)
               v=axis;
               vdiff = .8*v(4);

               for i=fitNum
                  plot(handle,find(sigIndex(:,i)==1),vdiff*ones(length(find(sigIndex(:,i)==1)),1)-i*.1,strcat('.',FitResult.colors{mod(i-1,length(FitResult.colors))+1})); hold on;
               end
            end
           ylabel('Fit Coefficients','Interpreter','latex');
           xtickLabels = fitObj.getPlotParams.xLabels;
           xticks = 1:(length(xtickLabels));
           
           set(handle,'xtick',xticks,'xtickLabel',xtickLabels,'FontSize',6);
           if(max(fitObj.numCoeffs)>1)
            xticklabel_rotate([],90,[],'Fontsize',6);
           end
%            hT=rotateticklabel(gca,-90);
           legend(handle,fitObj.lambda.dataLabels,'Location','Best');
           %axis tight;

        end
        function plotResults(fitObj)
            % plotResults(fitObj)
            % Generates KS plot, auto-correlation function of the inverse
            % gaussian transformed rescaled ISIs, the sequential
            % correlation coefficient between neigboring pairs of the
            % rescaled ISIs (zj vs. zj-1), the GLM regression coefficients,
            % and the Point Process Residual.
                scrsz = get(0,'ScreenSize');
                figure('Position',[scrsz(3)*.1 scrsz(4)*.1 scrsz(3)*.8 scrsz(4)*.8]);
                
                subplot(2,4,[1 2]); fitObj.KSPlot; %make the plot
                text(.45, .95,strcat('Neuron:',num2str(fitObj.neuronNumber)));
                subplot(2,4,3); fitObj.plotInvGausTrans;
                subplot(2,4,4); fitObj.plotSeqCorr;
                subplot(2,4,[7 8]); fitObj.plotResidual;
                subplot(2,4,[5 6]); fitObj.plotCoeffs;
        end
        function handle = KSPlot(fitObj)
            % handle = KSPlot(fitObj)
            % computes the K-S plot for each of the the candidate rate
            % functions in this FitResult object. These candidate rate
            % functions are numbered according to the order in which they
            % were added to the FitResult.
            h=gcf; 
            %h=[];
            figure(h); 
        %     size(xAxis) 
        %     size(KSSorted)
            N = length(fitObj.KSStats.KSSorted);
            xaxis = fitObj.KSStats.xAxis(:,1);
            handle=plot(fitObj.KSStats.xAxis,fitObj.KSStats.KSSorted, xaxis,xaxis, 'k-.',xaxis, xaxis+1.36/sqrt(N), 'r', xaxis,xaxis-1.36/sqrt(N), 'r' );

            %set(gca,'xtick',[],'ytick',[],'ztick', [])
            axis( [0 1 0 1] );
            dataLabels = cell(1,fitObj.lambda.dimension);
            for i=1:fitObj.lambda.dimension
                dataLabels{i} = fitObj.lambda.dataLabels{i};
            end
            legend(dataLabels,'Location','Best');
            xlabel('Uniform CDF');
            ylabel('Empirical CDF of Rescaled ISIs');
            title('KS Plot with 95% Confidence Intervals');


        end
        
        function structure = toStructure(fitObj)
            %
            fnames = fieldnames(fitObj);
            
            for i=1:length(fnames)
                
                currObj = fitObj.(fnames{i});
                if(strcmp(fnames{i},'histObjects')||strcmp(fnames{i},'ensHistObjects'))
                    for j=1:fitObj.numResults
                        tempObj = fitObj.(fnames{i}){j};
                        if(~isempty(tempObj))
                            structure.(fnames{i}){j} = tempObj.toStructure;
                        else
                            structure.(fnames{i}){j} = tempObj;
                        end
                    end
                elseif(strcmp(fnames{i},'invGausStats'))
                    tempNames = fieldnames(fitObj.(fnames{i}));
                    for j=1:length(tempNames)
                       tempObj = currObj.(tempNames{j});
                       if(~isempty(tempObj))
                        structure.(fnames{i}).(tempNames{j})=  tempObj.dataToStructure;
                       else
                         structure.(fnames{i}).(tempNames{j})=  tempObj;  
                       end
                        
                    end
                    
                else
                
                    if(isa(currObj,'double')||isa(currObj,'cell'))
                        structure.(fnames{i}) = currObj;
                    elseif(isa(currObj,'Covariate') ||isa(currObj,'ConfigColl')||isa(currObj,'nspikeTrain'))
                        structure.(fnames{i}) = currObj.toStructure;
                    elseif(isa(currObj,'SignalObj'))
                        structure.(fnames{i})  = currObj.dataToStructure;
                    elseif(isa(currObj,'struct'))
                        structure.(fnames{i}) = currObj;
                    end
                end
            end
            
        end
        

        function handle = plotSeqCorr(fitObj)
            % handle = plotSeqCorr(fitObj)
            % plot zj+1 against zj
            
            %colors = {'.b','.g','.r','.c','.m','.y','.k'};
            rho=zeros(1,fitObj.numResults);
            pval=zeros(1,fitObj.numResults);
            dataLabels = fitObj.lambda.dataLabels;
            for i=1:fitObj.numResults
               handle = plot(fitObj.Z(1:end-1,i),fitObj.Z(2:end,i),strcat('.',Analysis.colors{mod(i-1,length(Analysis.colors))+1})); hold on;
               [rhoTemp,p]= corrcoef(fitObj.Z(1:end-1,i),fitObj.Z(2:end,i));%handle=scatterhist(fitResults.Z(1:end-1,i),fitResults.Z(2:end,i))
               
               [~,columns]=size(rhoTemp);
                if(columns>1)
                    rho(i) = rhoTemp(1,2);
                    pval(i)= p(1,2);
                else
                    rho(i) = rhoTemp;
                    pval(i)= p;
                end
               dataLabels{i} = strcat(dataLabels{i},', \rho=',num2str(rho(i),'%0.2g'),' (p=',num2str(pval(i),'%0.2g'),')');
                %get(h,'AlphaData');
                %set(h,'FaceAlpha',0.2,'EdgeAlpha',0.8,'EdgeColor',color{i});
            end
            
           
            legend(dataLabels,'Location','Best');            
            ylabel('z_{j+1}'); xlabel('z_j');
            axis tight;
        end
        function handle = plotInvGausTrans(fitObj)
            %[rows,colm] = size(fitObj.X);
            %index=find(fitObj.invGausStats.lags==1);
            %lags=fitObj.invGausStats.lags;
            rhoSig=fitObj.invGausStats.rhoSig;
            n=length(fitObj.X);
            confBoundSig = fitObj.invGausStats.confBoundSig;
            handle=[];
%              for i=1:colm
%                     %i
%                     htemp=plot(lags',rho(:,i),strcat('.',FitResults.colors{mod(i-1,length(Analysis.colors))+1}));
%                     handle=[handle,htemp];
%                     hold on; 
%                     %labelArray{i} = ['Fit ' num2str(i)];
%              end
            
            rhoSig.plot;
            legend(fitObj.lambda.dataLabels,'Location','Best');            
            %legend(h,labelArray); 
            hold on; confBoundSig.plot;
  
        end
        function handle = plotResidual(fitObj)
            % handle = plotResidual(fitObj)
            % Plots the Point Process Residual
            handle=fitObj.Residual.plot;
            legend off;
            legend(fitObj.Residual.dataLabels,'Location','Best'); 
        end
        
        
        function setKSStats(fitObj, Z, U, xAxis, KSSorted, ks_stat)
            % setKSStats(fitObj, Z, xAxis, KSSorted, ks_stat)
            % Allows KS statistics to be set after object creation
            % Z: Rescaled ISIs from the Time Rescaling Theorem
            % xAxis: xAxis of the KS plot
            % KSSorted: the sorted values of Uj=1-exp(-zj)
            % ks_stat: the maximum deviation from the 45 degree line for
            % all of the fits.
            % 
            fitObj.Z        =Z;
            fitObj.U        =U;
            fitObj.KSStats.xAxis    =xAxis;
            fitObj.KSStats.KSSorted =KSSorted;
            fitObj.KSStats.ks_stat  =ks_stat;
            N = length(fitObj.KSStats.KSSorted);
            fitObj.KSStats.withinConfInt = ks_stat<1.36/sqrt(N);
        end
        function setInvGausStats(fitObj, X,rhoSig,confBoundSig)
            % setInvGausStats(fitObj,X,rhoSig,confBoundSig)
            % Sets the inverse gaussian transformed rescaled ISIs and the
            % confidence bounds after the object has been created.
            %fitObj.U=U;
            fitObj.X=X;
            fitObj.invGausStats.rhoSig=rhoSig;
            fitObj.invGausStats.confBoundSig=confBoundSig;
        end        
        function setFitResidual(fitObj,M)
           % setFitResidual(fitObj,M). 
           % Adds the point process residual to the FitResult object
           fitObj.Residual = M; 
        end
        
        
            
    end
    
    methods (Static)
        
        function fitObj = fromStructure(structure)
            if(isa(structure,'struct'))
                spikeObj=nspikeTrain.fromStructure(structure.neuralSpikeTrain);
                lambda=Covariate.fromStructure(structure.lambda);
                rhoSig=SignalObj.signalFromStruct(structure.invGausStats.rhoSig);
                confBoundSig = SignalObj.signalFromStruct(structure.invGausStats.confBoundSig);
                M = Covariate.fromStructure(structure.Residual);
                for i=1:structure.numResults
                    histObjects{i} = History.fromStructure(structure.histObjects{i});
                    ensHistObject{i} = History.fromStructure(structure.ensHistObjects{i});
                end
                configColl = ConfigColl.fromStructure(structure.configs);
                fitObj=FitResult(spikeObj,structure.covLabels,structure.numHist,histObjects,ensHistObject,lambda,structure.b, structure.dev, structure.stats,structure.AIC,structure.BIC,configColl,structure.XvalData,structure.XvalTime,structure.fitType);
                fitObj.setKSStats(structure.Z,structure.U, structure.KSStats.xAxis, structure.KSStats.KSSorted, structure.KSStats.ks_stat);
                fitObj.setInvGausStats(structure.X,rhoSig,confBoundSig);
                fitObj.setFitResidual(M);
            elseif(isa(structure,'cell')) %cell array of FitResult objects
                fitObj = cell(size(structure));
               for i=1:length(structure)
                  fitObj{i} = FitResult.fromStructure(structure{i}); 
               end
            end
            
        end
        
        function structCell = CellArrayToStructure(fitResObjCell)
           if(isa(fitResObjCell,'FitResult'))
               structCell = fitResObjCell.toStructure;
           elseif(isa(fitResObjCell,'cell'))
               if(isa(fitResObjCell{1},'FitResult'))
                   structCell = cell(size(fitResObjCell));
                  for i=1:length(fitResObjCell)
                     structCell{i} = fitResObjCell{i}.toStructure;
                  end
               end
           end
            
        end
        
    end
    
end

%Helper functions
function hText = xticklabel_rotate(XTick,rot,varargin)
    %hText = xticklabel_rotate(XTick,rot,XTickLabel,varargin)     Rotate XTickLabel
    %
    % Syntax: xticklabel_rotate
    %
    % Input:    
    % {opt}     XTick       - vector array of XTick positions & values (numeric) 
    %                           uses current XTick values or XTickLabel cell array by
    %                           default (if empty) 
    % {opt}     rot         - angle of rotation in degrees, 90° by default
    % {opt}     XTickLabel  - cell array of label strings
    % {opt}     [var]       - "Property-value" pairs passed to text generator
    %                           ex: 'interpreter','none'
    %                               'Color','m','Fontweight','bold'
    %
    % Output:   hText       - handle vector to text labels
    %
    % Example 1:  Rotate existing XTickLabels at their current position by 90°
    %    xticklabel_rotate
    %
    % Example 2:  Rotate existing XTickLabels at their current position by 45° and change
    % font size
    %    xticklabel_rotate([],45,[],'Fontsize',14)
    %
    % Example 3:  Set the positions of the XTicks and rotate them 90°
    %    figure;  plot([1960:2004],randn(45,1)); xlim([1960 2004]);
    %    xticklabel_rotate([1960:2:2004]);
    %
    % Example 4:  Use text labels at XTick positions rotated 45° without tex interpreter
    %    xticklabel_rotate(XTick,45,NameFields,'interpreter','none');
    %
    % Example 5:  Use text labels rotated 90° at current positions
    %    xticklabel_rotate([],90,NameFields);
    %
    % Note : you can not re-run xticklabel_rotate on the same graph. 
    %
    % 


    % This is a modified version of xticklabel_rotate90 by Denis Gilbert
    % Modifications include Text labels (in the form of cell array)
    %                       Arbitrary angle rotation
    %                       Output of text handles
    %                       Resizing of axes and title/xlabel/ylabel positions to maintain same overall size 
    %                           and keep text on plot
    %                           (handles small window resizing after, but not well due to proportional placement with 
    %                           fixed font size. To fix this would require a serious resize function)
    %                       Uses current XTick by default
    %                       Uses current XTickLabel is different from XTick values (meaning has been already defined)

    % Brian FG Katz
    % bfgkatz@hotmail.com
    % 23-05-03
    % Modified 03-11-06 after user comment
    %	Allow for exisiting XTickLabel cell array

    % Other m-files required: cell2mat
    % Subfunctions: none
    % MAT-files required: none
    %
    % See also: xticklabel_rotate90, TEXT,  SET

    % Based on xticklabel_rotate90
    %   Author: Denis Gilbert, Ph.D., physical oceanography
    %   Maurice Lamontagne Institute, Dept. of Fisheries and Oceans Canada
    %   email: gilbertd@dfo-mpo.gc.ca  Web: http://www.qc.dfo-mpo.gc.ca/iml/
    %   February 1998; Last revision: 24-Mar-2003

    % check to see if xticklabel_rotate has already been here (no other reason for this to happen)
    if isempty(get(gca,'XTickLabel')),
        error('xticklabel_rotate : can not process, either xticklabel_rotate has already been run or XTickLabel field has been erased')  ;
    end

    % if no XTickLabel AND no XTick are defined use the current XTickLabel
    %if nargin < 3 & (~exist('XTick') | isempty(XTick)),
    if (nargin < 3 || isempty(varargin{1})) & (~exist('XTick') | isempty(XTick)),
        xTickLabels = get(gca,'XTickLabel')  ; % use current XTickLabel
        if ~iscell(xTickLabels)
            % remove trailing spaces if exist (typical with auto generated XTickLabel)
            temp1 = num2cell(xTickLabels,2)         ;
            for loop = 1:length(temp1),
                temp1{loop} = deblank(temp1{loop})  ;
            end
            xTickLabels = temp1                     ;
        end
    varargin = varargin(2:length(varargin));	
    end

    % if no XTick is defined use the current XTick
    if (~exist('XTick') | isempty(XTick)),
        XTick = get(gca,'XTick')        ; % use current XTick 
    end

    %Make XTick a column vector
    XTick = XTick(:);

    if ~exist('xTickLabels'),
        % Define the xtickLabels 
        % If XtickLabel is passed as a cell array then use the text
        if (length(varargin)>0) & (iscell(varargin{1})),
            xTickLabels = varargin{1};
            varargin = varargin(2:length(varargin));
        else
            xTickLabels = num2str(XTick);
        end
    end    

    if length(XTick) ~= length(xTickLabels),
        error('xticklabel_rotate : must have same number of elements in "XTick" and "XTickLabel"')  ;
    end

    %Set the Xtick locations and set XTicklabel to an empty string
    set(gca,'XTick',XTick,'XTickLabel','')

    if nargin < 2,
        rot = 90 ;
    end

    % Determine the location of the labels based on the position
    % of the xlabel
    hxLabel = get(gca,'XLabel');  % Handle to xlabel
    xLabelString = get(hxLabel,'String');

    % if ~isempty(xLabelString)
    %    warning('You may need to manually reset the XLABEL vertical position')
    % end

    set(hxLabel,'Units','data');
    xLabelPosition = get(hxLabel,'Position');
    y = xLabelPosition(2);

    %CODE below was modified following suggestions from Urs Schwarz
    y=repmat(y,size(XTick,1),1);
    % retrieve current axis' fontsize
    fs = get(gca,'fontsize');

    % Place the new xTickLabels by creating TEXT objects
    hText = text(XTick, y, xTickLabels,'fontsize',fs);

    % Rotate the text objects by ROT degrees
    set(hText,'Rotation',rot,'HorizontalAlignment','right',varargin{:})

    % Adjust the size of the axis to accomodate for longest label (like if they are text ones)
    % This approach keeps the top of the graph at the same place and tries to keep xlabel at the same place
    % This approach keeps the right side of the graph at the same place 

    set(get(gca,'xlabel'),'units','data')           ;
        labxorigpos_data = get(get(gca,'xlabel'),'position')  ;
    set(get(gca,'ylabel'),'units','data')           ;
        labyorigpos_data = get(get(gca,'ylabel'),'position')  ;
    set(get(gca,'title'),'units','data')           ;
        labtorigpos_data = get(get(gca,'title'),'position')  ;

    set(gca,'units','pixel')                        ;
    set(hText,'units','pixel')                      ;
    set(get(gca,'xlabel'),'units','pixel')          ;
    set(get(gca,'ylabel'),'units','pixel')          ;

    origpos = get(gca,'position')                   ;
    textsizes = cell2mat(get(hText,'extent'))       ;
    longest =  max(textsizes(:,4))                  ;

    laborigext = get(get(gca,'xlabel'),'extent')    ;
    laborigpos = get(get(gca,'xlabel'),'position')  ;


    labyorigext = get(get(gca,'ylabel'),'extent')   ;
    labyorigpos = get(get(gca,'ylabel'),'position') ;
    leftlabdist = labyorigpos(1) + labyorigext(1)   ;

    % assume first entry is the farthest left
    leftpos = get(hText(1),'position')              ;
    leftext = get(hText(1),'extent')                ;
    leftdist = leftpos(1) + leftext(1)              ;
    if leftdist > 0,    leftdist = 0 ; end          % only correct for off screen problems

    botdist = origpos(2) + laborigpos(2)            ;
    newpos = [origpos(1)-leftdist longest+botdist origpos(3)+leftdist origpos(4)-longest+origpos(2)-botdist]  ;
    set(gca,'position',newpos)                      ;

    % readjust position of nex labels after resize of plot
    set(hText,'units','data')                       ;
    for loop= 1:length(hText),
        set(hText(loop),'position',[XTick(loop), y(loop)])  ;
    end


    % adjust position of xlabel and ylabel
    laborigpos = get(get(gca,'xlabel'),'position')  ;
    set(get(gca,'xlabel'),'position',[laborigpos(1) laborigpos(2)-longest 0])   ;

    % switch to data coord and fix it all
    set(get(gca,'ylabel'),'units','data')                   ;
    set(get(gca,'ylabel'),'position',labyorigpos_data)      ;
    set(get(gca,'title'),'position',labtorigpos_data)       ;

    set(get(gca,'xlabel'),'units','data')                   ;
        labxorigpos_data_new = get(get(gca,'xlabel'),'position')  ;
    set(get(gca,'xlabel'),'position',[labxorigpos_data(1) labxorigpos_data_new(2)])   ;


    % Reset all units to normalized to allow future resizing
    set(get(gca,'xlabel'),'units','normalized')          ;
    set(get(gca,'ylabel'),'units','normalized')          ;
    set(get(gca,'title'),'units','normalized')          ;
    set(hText,'units','normalized')                      ;
    set(gca,'units','normalized')                        ;

    if nargout < 1,
        clear hText
    end

end
function [uniqueLabels, indexIntoOriginal, restoreIndex] = getUniqueLabels(covLabels)
            offset = 0;
            for i=1:length(covLabels)
                currLabels = covLabels{i};                
                allLabels((1:length(currLabels))+offset) = currLabels;
                offset=length(allLabels);
            end
            [uniqueLabels, indexIntoOriginal, restoreIndex] = unique(allLabels);
end
        

   
##### SOURCE END #####
--></body></html>