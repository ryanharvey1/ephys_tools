%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%                                                                     %%%
%%%                   Perform Co-Occurrence Analysis                    %%%
%%%                                                                     %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Tmaze project
% This script loads the inputData generated by the script PAPER_Generate_inputData
% as well as the candidate events generated by the script
% PAPER_Generate_Candidates or another similar script. 
% It computes the pairwise coactivity of left and right place cells. 
%
% There are 2 output variables coocData (the data) and coocP (data
% formatted for use in plotting...PAPER_Plot_CoOccurrence)
%
% coocData has the same overall organization as inputData, except that in
% the L and R subfields are the following fields:
% ...L.S       (the S used)
%   .L.Q       (the Q matrix used)
%   .L.ALLp    (the outputs of CoOccurQ)
%     .ALLp.p0
%        ...
%     .ALLp.p4
%     .ALLp.p5
%
% aacarey initial Oct 2015, revisions Nov 2015, Dec 2015
% MvdM Nov 2015 additions

clearvars -except CFG

%% WHAT DO YOU WANT THIS SCRIPT TO DO??

% what to load and where to find it
cfg.inputData_fn = 'inputData'; % the script knows the proper file extension (.mat) so don't put it here
cfg.inputData_fd = [pwd,'\data']; % 'E:\Documents\TmazePaper\data'; 'D:\My_Documents\Dropbox\projects\Alyssa';

% what to call the output and where to put it?
cfg.writeFiles = 1;
cfg.output_fn = 'coOccurrence';
cfg.output_fd = cfg.inputData_fd;

% Which caniddtaes file do you want to use?
cfg.whichCandidates = '-candidates'; % '-precandidates' or '-candidates'...make sure to include the hyphen to distinguish the similar names

% do you want to compute co-occurrence for the whole session, or only part of it? 
cfg.whichEvents = 'prerecord'; % 'all', 'prerecord', 'task', 'postrecord', 'allITI', 'equalBehaviorITI'

% which spiketrains to use? * note that these are saved inside of inputData
cfg.whichS = 'unique'; % 'unique', 'nonunique' or 'trajectory'; unique cells 
% are left-only or right-only, and nonunique are any cells with left fields
% and any cells with right fields, even if they have fields on the opposite
% arm. Trajectory cells are any cells that were active along L or R runs.
% This means that [most or all] cells on the central arm will belong in both
% the L and R groups. Trajectory cells include nonunique cells include
% unique cells.

% What's the minimum cluster rating you want to use?
cfg.min_cluster_quality = 5;

% What's the minimum number of active cells for a candidate to be kept?
cfg.minCells = 2;

% Do you want to use the same number of L and R place cells?
% If 1, subset the larger group to match the number in  the smaller group;
% if 0, don't (uses random but deterministic subset by reseeding rng)
cfg.useSubset = 0;

% TODO which co-coccurrence method to use? ChengFrank, Dupret?

% Number of shuffles to use for permutation test in CoOccurQ
cfg.nShuffle = 250; % use 10 000

% Which method do you want CoOccurQ to use for shuffling?
cfg.method = 'naive'; % 'naive','ballot','continuous'

% which events to use for computing shuffled (expected) co-occurrence?
cfg.shuffleQ = 'selectedEvents'; % 'selectedEvents' or 'allEvents' 

% TODO what time bin to use for co-occurrence? Default is start and end of
% event, but need to be able to override with fixed width
cfg.win = 0.1; % if empty [], co-occurrence is computed based on the exact 
% detected event boundaries. Specify a single value representing the
% desired time bin size. For example, putting 0.1 means you are asking for
% a 100 ms window, with 50 ms on either side of the center of the detected
% event.

% Do you want to exclude pairs recorded on the same tetrode?
cfg.useMask = 1; % If 1, exclude pairs from the same tt, if 0, don't

% Do you want to reseed the random number generator?
cfg.resetRNG = 1; % 1 yes, 0 no.

% WHICH RATS (caution, highly suggested to include all rats)
cfg.rats = TmazeRats; 
% 'R042','R044','R050','R064' note that it's probably safer do 
% all rats at the same time so that we can guarantee that all co-occurrence 
% data is generated using the same parameters

%% If master config exists, process cfg

if exist('CFG','var')
    cfg = ProcessConfig2(cfg,CFG.cc);
end

%% Start the diary

iWasHere = pwd; % save where I started before cding all over the place
tic
if cfg.writeFiles
    cd(cfg.output_fd)
    diary([cfg.output_fn,'_',cfg.whichEvents,'_text.txt'])
    cd(iWasHere)
end

disp('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~')
disp('~~~              GENERATING CO-OCCURRENCE DATA                  ~~~')
disp('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~')

fprintf('\nDATE of script run: %s\n',datestr(now));

%% Make sure the user didn't make a typo or whatever, but at the same time, print some useful info to the command window

fprintf('\nYou have selected the following rats:\n')
for iRat = 1:length(cfg.rats)
    switch cfg.rats{iRat}
        case 'R042'
            disp('R042: Captain Ratsworth at your command ;)')
        case 'R044'
            disp('R044')
        case 'R050'
            disp('R050')
        case 'R064'
            disp('R064')
        otherwise
            error('Unrecognized rat in cfg.rats')
    end
end

disp(' ')
switch cfg.whichS
    case 'unique'
        disp('You have selected [unique] left-arm-only and right-arm-only spiketrains')
        cfg.whichS = 'S_arm_unique';
    case 'nonunique'
        disp('You have selected [nonunique] left and right arm spiketrains')
        cfg.whichS = 'S_arm';
    case 'uniquetrajectory';
        disp('You have selected [unique] left and right trajectory spiketrains')
        cfg.whichS = 'S_traj_unique';
    case 'trajectory'
        disp('You have selected left and right [trajectory] spiketrains')
        cfg.whichS = 'S_traj';
    otherwise
        error('Unrecognized cfg.whichS. Better check that spelling ^_^')
end

disp(' ')
switch cfg.whichEvents 
    case 'all'
        disp('You have selected to perform co-occurrence analysis on all candidates')
    case 'prerecord'
        disp('You have selected to perform co-occurrence analysis on prerecord candidates')
    case 'postrecord'
        disp('You have selected to perform co-occurrence analysis on postrecord candidates')
    case 'task'
        disp('You have selected to perform co-occurrence analysis on task candidates')
    case 'allITI'
        disp('You have selected to perform co-occurrence analysis on all intertrial intervals')
    case 'equalBehaviorITI'
        disp('You have selected to perform co-occurrence analysis on intertrial intervals with equal preceding behavior')
    otherwise
        error('Unrecognized cfg.whichEvents. Better check that spelling ^_^')
end

if ~ismember(cfg.min_cluster_quality,[1 2 3 4 5])
    error('Minimum cluster quality must be between 1 and 5.')
end

% set some non-configurable variables
arms = {'L','R'}; % shortforms for left and right arms, used for storing corresponding data

%% Load the inputData

cd(cfg.inputData_fd)
load([cfg.inputData_fn,'.mat'])

disp(' ')
disp(['This inputData was generated on ',inputData.hdr.date])

base_fp = getBaseFP; % where source data is stored on this particular machine 

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%                                                                     %%%
%%%                       Main body of script                           %%%
%%%                                                                     %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%~~~~~~~~~~~~~~~~~~~~~~ iterate through each rat ID ~~~~~~~~~~~~~~~~~~~~~~~
for iRat = 1:length(cfg.rats)
    fprintf('\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n')
    fprintf('~~  GENERATING CO-OCCURRENCE DATA FOR %s ~~\n',cfg.rats{iRat});
    disp('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~')
    
    %~~~~~~~~~~~~~~~~~~~~ work through each session ~~~~~~~~~~~~~~~~~~~~~~~
    for iSession = 1:length(inputData.(cfg.rats{iRat}))
        sessionID = inputData.(cfg.rats{iRat})(iSession).sessionID;
        
        % save some data into the output struct
        sessionCC.sessionID = sessionID;
        fprintf('\n*** Working on: %s ***\n',sessionID)
        sessionCC.restrictionType = inputData.(cfg.rats{iRat})(iSession).restrictionType;
        fprintf('\nRestriction type: %s\n',sessionCC.restrictionType)
        
        % load and rename the candidates
        cd([base_fp,'\',cfg.rats{iRat},'\',sessionID]) 
        evt = loadpop([sessionID,cfg.whichCandidates,'.mat']); % assign the loaded variable to "evt" regardless of what it is actually called
        
        LoadExpKeys; LoadMetadata;
        
        if strcmp(cfg.method,'ballot') % load CSC
            cfg_temp = [];
            cfg_temp.fc = ExpKeys.goodSWR(1);
            CSC = LoadCSC(cfg_temp);
        end
        
        % choose which events to use       
        fprintf('nEvents loaded: %d\n',length(evt.tstart));
        evt_original = evt; % keep full set for later if needed
        switch cfg.whichEvents % now restrict
            case 'all'
                % do nothing with evt restriction
            case 'prerecord'
                evt = RestrictIV([],evt,ExpKeys.prerecord(1),ExpKeys.prerecord(2));
            case 'postrecord'
                evt = RestrictIV([],evt,ExpKeys.postrecord(1),ExpKeys.postrecord(2));
            case 'task'
                evt = RestrictIV([],evt,ExpKeys.task(1),ExpKeys.task(2));                
            case 'allITI'
                evt = RestrictIV(evt,metadata.taskvars.rest_iv.tstart(1),metadata.taskvars.rest_iv.tend(end));
            case 'equalBehaviorITI'
                eq_iv = GetEqualBehaviorIV([],metadata);
                evt = RestrictIV([],evt,eq_iv);
            otherwise
                error('Unrecognized cfg.whichEvents')
        end
        fprintf('nEvents after cfg.whichEvents restrict: %d\n',length(evt.tstart));
        
        if ~isempty(cfg.minCells)
           cfg_temp = []; cfg_temp.threshold = cfg.minCells; cfg_temp.operation = '>=';
           evt = SelectIV(cfg_temp,evt,'nActiveCells');
        end
        
        % Work with S
        for iArm = 1:length(arms)
           sessionCC.(arms{iArm}).S = inputData.(cfg.rats{iRat})(iSession).(arms{iArm}).(cfg.whichS);
            
            if cfg.min_cluster_quality < 5 % then kick out some spiketrains
                cfg_temp = [];
                cfg_temp.threshold = cfg.min_cluster_quality;
                cfg_temp.operation = '<';
                sessionCC.(arms{iArm}).S = SelectTS(cfg_temp,sessionCC.(arms{iArm}).S,'rating');
            end 
        end
        
        % Subset the larger S group if requested
        if cfg.useSubset
           nL = length(sessionCC.L.S.t);
           nR = length(sessionCC.R.S.t);
           
           if nL > nR
               disp('Subsetting left cells...'); fprintf('\b')
               sessionCC.L.S = subset([],sessionCC.L.S,nR);
           elseif nL < nR
               disp('Subsetting right cells...'); fprintf('\b')
               sessionCC.R.S = subset([],sessionCC.R.S,nL);
           end
        end
        
        % make a Q-matrix
        % A Q-matrix is organized such that each row corresponds to a cell, and each
        % column groups the spikes into time bins. Thus, each column contains information
        % about which cells were active together in a given time bin.
        
        for iArm = 1:length(arms)
            sessionCC.(arms{iArm}).Q = [];
            
            if ~isempty(sessionCC.(arms{iArm}).S.t) && ~isempty(evt.tstart)

                cfg_temp = []; cfg_temp.win = cfg.win;
                sessionCC.(arms{iArm}).Q = MakeQfromS2(cfg_temp,sessionCC.(arms{iArm}).S,evt);
                
                % also compute full Q-matrix if needed -- TODO: avoid
                % duplication
                switch cfg.shuffleQ
                    case 'selectedEvents'
                        % do nothing
                    case 'allEvents' % compute full Q-matrix
                        % sessionCC.(arms{iArm}).fullQ = MakeQfromS2(cfg_temp,inputData.(cfg.rats{iRat})(iSession).(arms{iArm}).(cfg.whichS),evt_original);
                        sessionCC.(arms{iArm}).fullQ = MakeQfromS2(cfg_temp,sessionCC.(arms{iArm}).S,evt_original);
                        
                    otherwise
                       error('Unknown shuffleQ option specified.');
                end % of shuffleQ switch
            end % of passing cell number check
        end % of arms
        
        % compute co-occurrence (this could have been done in the loop above)
        
        cfg_temp = [];
        cfg_temp.useMask = cfg.useMask;
        cfg_temp.nShuffle = cfg.nShuffle;
        cfg_temp.outputFormat = 'vectorU';
        cfg_temp.resetRNG = cfg.resetRNG;
        
        switch cfg.method
            case 'naive'
            case 'ballot'
                cfg_temp.lfp = CSC;
                cfg_temp.iv = evt;
            otherwise
                error('Unrecognized config option in cfg.method')
        end
        cfg_temp.method = cfg.method;
        
        for iArm = 1:length(arms)
            if ~isempty(sessionCC.(arms{iArm}).Q)
                switch cfg.shuffleQ
                    case 'selectedEvents'
                        cfg_temp.shuffleQ = [];
                    case 'allEvents'
                        cfg_temp.shuffleQ = sessionCC.(arms{iArm}).fullQ;
                end
                Q_temp = sessionCC.(arms{iArm}).Q;
                sessionCC.(arms{iArm}).ALLp = CoOccurQ3(cfg_temp,Q_temp);
            else
               % equalBehaviorITI ended up with an empty Q for R042-19th. this was put in to bypass cases of empty Q which causes CoOccurQ to error
               sessionCC.(arms{iArm}).ALLp = struct('p0',NaN,'p1',NaN,'p2',NaN,'p3',NaN,'p4',NaN,'p5',NaN);
            end
        end
        
        % also do the co-occurrence for L and R cells in the same event
        % (not done yet)
        
        
        
        
        
        % put it in the output variable
        coocData.(cfg.rats{iRat})(iSession) = sessionCC;
        
    end
end

%% COLLECT CO-OCCURRENCE DATA INTO INDIVDUAL PVALS FOR EACH RAT (for plotting
% later)
% make an empty struct that can be used to collect data
COMBp.p0 = []; % combined pvals for all food sessions for all rats
COMBp.p1 = [];
COMBp.p2 = [];
COMBp.p3 = [];
COMBp.p4 = [];
COMBp.p5 = [];

% intialize combined (all rats) data collector
coocP.all.foodL = COMBp; % left pairs on food day
coocP.all.foodR = COMBp; % right pairs on food day
coocP.all.waterL = COMBp;
coocP.all.waterR = COMBp;

pnames = fieldnames(COMBp); % for the pval concatenating loop down below
% pnames = {'p0';'p1';'p2';'p3';'p4'}; 

%~~~~~~~~~~~~~~~~~~~~~ work through each rat~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 for iRat = 1:length(cfg.rats)  
     disp(' '); disp('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~')
     disp(['~~  COLLECTING CO-OCCURRENCE DATA FOR ',cfg.rats{iRat},' ~~'])
     disp('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~')

    % initialize combined p vals struct
    %pvalFields = fieldnames(cooc.(cfg.rats{iRat})(iSession).(arms{iArm}).ALLp); % pvalFields will be 'p0','p1','p2' and so on
    %COMBp = cell2struct(cell(size(pvalFields)),pvalFields,1); % this takes the field names, generates an empty cell, and then turns the cell into an empty struct with those field names
    
    % could put this in a loop instead:
    coocP.(cfg.rats{iRat}).foodL = COMBp;
    coocP.(cfg.rats{iRat}).foodR = COMBp;
    coocP.(cfg.rats{iRat}).waterL = COMBp;
    coocP.(cfg.rats{iRat}).waterR = COMBp;
    
    %~~~~~~~~~~~~~~~~~~~~ iterate through sessions ~~~~~~~~~~~~~~~~~~~~~~~~
    for iSession = 1:length(coocData.(cfg.rats{iRat}))
        
        % get restriction type
        restrictionType = coocData.(cfg.rats{iRat})(iSession).restrictionType;
        
        %~~~~~~~~~~~~~~~~~ iterate through arms ~~~~~~~~~~~~~~~~~~~~~~~~~~~
        for iArm = 1:length(arms)
            %~~~~~~~~~~~~~ gather all proportion values ~~~~~~~~~~~~~~~~~~~
            for iPname = 1:length(pnames)
                % example of what the lines below looks like:
                % coocP.R042.foodL.p0 = [coocP.R042.food.L.p0; coocData.R042.foodL.ALLp.p0];
                coocP.(cfg.rats{iRat}).([restrictionType,arms{iArm}]).(pnames{iPname}) = [coocP.(cfg.rats{iRat}).([restrictionType,arms{iArm}]).(pnames{iPname}); coocData.(cfg.rats{iRat})(iSession).(arms{iArm}).ALLp.(pnames{iPname})]; % oh dear universe, i am not going to understand this next month
                % coocP.all.foodL.p0 = [coocP.all.food.L.p0; coocData.R042.foodL.ALLp.p0];
                coocP.all.([restrictionType,arms{iArm}]).(pnames{iPname}) = [coocP.all.([restrictionType,arms{iArm}]).(pnames{iPname}); coocData.(cfg.rats{iRat})(iSession).(arms{iArm}).ALLp.(pnames{iPname})];
            end
        end
    end
    % at the end of session data concatenation, get the mean proportions
%     contingency = fieldnames(coocP.(cfg.rats{iRat})); % the contingencies are foodL,foodR and so on. Maybe could use a better name than contingency?
%     for iCont = 1:length(contingency)
%         for iPname = 1:length(pnames)
%             %coocP.R042.foodL.p0 = nanmean(coocP.R042.foodL.p0);
%             coocP.(cfg.rats{iRat}).(contingency{iCont}).(pnames{iPname}) = nanmean(coocP.(cfg.rats{iRat}).(contingency{iCont}).(pnames{iPname}));
%         end
%     end
    
 end
contingency = {'foodL', 'foodR', 'waterL', 'waterR'};
 
 % get the mean pvals for combined rat data
 for iCont = 1:length(contingency) % 'foodL' 'foodR' 'waterL' 'waterR'
     %disp(contingency(iCont))
     for iPname = 1:length(pnames) % 'p0';'p1';'p2';'p3';'p4';'p5'
         p_temp = nan(size(cfg.rats)); % preallocate space for the p (co-occur) values for each rat. p0 through p5 will be grouped according to foodL and so on for all rats.
         p_count = 0; % how many p values we've added up so far
         for iRat = 1:length(cfg.rats)
             
             % p_temp = [coocP.R042.foodL.p0 coocP.R044.foodL.p0 coocP.R050.foodL.p0 coocP.R064.foodL.p0];
             p_temp(iRat) = nansum(coocP.(cfg.rats{iRat}).(contingency{iCont}).(pnames{iPname})); p_count = p_count + length(~isnan(coocP.(cfg.rats{iRat}).(contingency{iCont}).(pnames{iPname})));
             
             coocP.(cfg.rats{iRat}).(contingency{iCont}).(pnames{iPname}) = nanmean(coocP.(cfg.rats{iRat}).(contingency{iCont}).(pnames{iPname}));
         end
         % coocP.all.foodL.p0 = nanmean(p_temp);
         coocP.all.(contingency{iCont}).(pnames{iPname}) = nansum(p_temp)/p_count;
     end
 end


%%
if cfg.writeFiles
    disp(['Writing co-occurence data to .mat file in ',cfg.output_fd,'...'])
    cd(cfg.output_fd)
    save([cfg.output_fn,'_',cfg.whichEvents],'coocData','coocP')
else
    disp('WARNING: You have selected not to save the output data')
end

%% If master config exists, save config history

if exist('CFG','var')
    CFG = History(CFG,mfilename,cfg);
end

disp('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~')
disp('~~~             End of CoOccurrence run              ~~~')
disp('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~')
toc

if cfg.writeFiles; diary off; end
cd(iWasHere)